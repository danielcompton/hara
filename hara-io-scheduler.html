

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <meta name="google" value="notranslate">


    <title>io.scheduler</title>

    
  <link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/clojure.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/magula.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.2/angular.min.js"></script>
  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular-cookies.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.13.0/ui-bootstrap-tpls.min.js"></script>
  <script type="text/javascript" src="js/angular-highlightjs.min.js"></script>

  <link rel="stylesheet" type="text/css" href="css/rdash.min.css">
  <link rel="stylesheet" type="text/css" href="css/scrollspy.css">


  <script>
    window.console = window.console || function(t) {};
    window.open = function(){ console.log("window.open is disabled."); };
    window.print   = function(){ console.log("window.print is disabled."); };
  </script>

  <script>
    var app = angular.module('app', ['hljs']);
  </script>
  </head>

  <body ng-app="app" data-spy="scroll" data-target=".scrollspy">
  <!-- Fixed navbar -->
    <nav class="navbar navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html"><img src="img/logo.png"></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Guides <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="hara-class.html">class</a></li>
                <li><a href="hara-common.html">common</a></li>
                <li><a href="hara-component.html">component</a></li>
                <li><a href="hara-concurrent.html">concurrent</a></li>
                <li><a href="hara-concurrent-ova.html">concurrent.ova</a></li>
                <li><a href="hara-concurrent-procedure.html">concurrent.procedure</a></li>
                <li><a href="hara-data.html">data</a></li>
                <li><a href="hara-event.html">event</a></li>
                <li><a href="hara-expression.html">expression</a></li>
                <li><a href="hara-extend.html">extend</a></li>
                <li><a href="hara-function.html">function</a></li>
                <li><a href="hara-group.html">group</a></li>
                <li><a href="hara-io-environment.html">io.environment</a></li>
                <li><a href="hara-io-scheduler.html">io.scheduler</a></li>
                <li><a href="hara-io-watch.html">io.watch</a></li>
                <li><a href="hara-namespace.html">namespace</a></li>
                <li><a href="hara-object.html">object</a></li>
                <li><a href="hara-reflect.html">reflect</a></li>
                <li><a href="hara-sort.html">sort</a></li>
                <li><a href="hara-string.html">string</a></li>
                <li><a href="hara-time.html">time</a></li>
            </ul>
            </li>
            <li>
              <a href="https://github.com/zcaudate/hara" target="_blank">Github</a></li>
            <li>
              <a href="http://gitter.im/zcaudate/hara" target="_blank">Gitter</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


  <div class="container row">
    <div class="col-md-4 scrollspy pull-right">
      <ul id="nav" class="nav hidden-xs hidden-sm" data-spy="affix">
        <li><a href="#introduction">1  &nbsp;&nbsp; Introduction</a><ul class="nav"><li><a href="#installation">1.1  &nbsp;&nbsp; Installation</a></li><li><a href="#motivation">1.2  &nbsp;&nbsp; Motivation</a></li><li><a href="#other-libraries">1.3  &nbsp;&nbsp; Other Libraries</a></li></ul></li><li><a href="#concepts-and-design">2  &nbsp;&nbsp; Concepts and Design</a><ul class="nav"><li><a href="#seperation-of-concerns">2.1  &nbsp;&nbsp; Seperation of Concerns</a></li><li><a href="#thread-management">2.2  &nbsp;&nbsp; Thread Management</a></li><li><a href="#simulation-testing">2.3  &nbsp;&nbsp; Simulation Testing</a></li></ul></li><li><a href="#walkthrough">3  &nbsp;&nbsp; Walkthrough</a><ul class="nav"><li><a href="#creating-a-task">3.1  &nbsp;&nbsp; Creating a Task</a></li><li><a href="#starting-out">3.2  &nbsp;&nbsp; Starting out</a></li><li><a href="#components">3.3  &nbsp;&nbsp; Components</a></li><li><a href="#schedule">3.4  &nbsp;&nbsp; Schedule</a></li></ul></li><li><a href="#simulation">4  &nbsp;&nbsp; Simulation</a><ul class="nav"><li><a href="#y2-k-revisited">4.1  &nbsp;&nbsp; Y2K Revisited</a></li><li><a href="#interval-and-pause">4.2  &nbsp;&nbsp; Interval and Pause</a></li></ul></li><li><a href="#task-management">5  &nbsp;&nbsp; Task Management</a><ul class="nav"><li><a href="#add-task">5.1  &nbsp;&nbsp; add-task</a></li><li><a href="#reschedule-task">5.2  &nbsp;&nbsp; reschedule-task</a></li><li><a href="#reparametise-task">5.3  &nbsp;&nbsp; reparametise-task</a></li><li><a href="#disable-task">5.4  &nbsp;&nbsp; disable-task</a></li><li><a href="#enable-task">5.5  &nbsp;&nbsp; enable-task</a></li><li><a href="#delete-task">5.6  &nbsp;&nbsp; delete-task</a></li><li><a href="#empty-tasks">5.7  &nbsp;&nbsp; empty-tasks</a></li></ul></li><li><a href="#globals">6  &nbsp;&nbsp; Globals</a><ul class="nav"><li><a href="#defaults">6.1  &nbsp;&nbsp; Defaults</a></li><li><a href="#date-as-data">6.2  &nbsp;&nbsp; Date as data</a></li><li><a href="#timezone">6.3  &nbsp;&nbsp; Timezone</a></li></ul></li><li><a href="#realtime-management">7  &nbsp;&nbsp; Realtime Management</a><ul class="nav"><li><a href="#trigger">7.1  &nbsp;&nbsp; trigger!</a></li><li><a href="#list-and-kill">7.2  &nbsp;&nbsp; List and kill</a></li><li><a href="#realtime-demo">7.3  &nbsp;&nbsp; Realtime demo</a></li><li><a href="#shutdown-and-restart">7.4  &nbsp;&nbsp; Shutdown and Restart</a></li></ul></li><li><a href="#api">8  &nbsp;&nbsp; API</a></li><li><a href="#cronj">9  &nbsp;&nbsp; Cronj</a><ul class="nav"><li><a href="#upgrade">9.1  &nbsp;&nbsp; Upgrade</a></li><li><a href="#constructor">9.2  &nbsp;&nbsp; Constructor</a></li></ul></li><li><a href="#links-and-resources">10  &nbsp;&nbsp; Links and Resources</a></li>
      </ul>
    </div>
    <div class="col-md-8" id="content">
      <div class="jumbotron">
        <div class="container">
          <h1>io.scheduler</h1>
          <h4>easy and intuitive task scheduling</h4>
        </div>
      </div>
      <section class="chapter" id="introduction"><h2 class="chapter">1  &nbsp;&nbsp; Introduction</h2><section class="section" id="installation"><h3 class="section">1.1  &nbsp;&nbsp; Installation</h3><div class="paragraph"><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;im.chit/hara.io.scheduler &quot;2.3.0&quot;&#93;
</code></pre></div><div class="paragraph"><p>All functions are in the <code>hara.io.scheduler</code> namespace.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(use 'hara.io.scheduler)</div></div></section><section class="section" id="motivation"><h3 class="section">1.2  &nbsp;&nbsp; Motivation</h3><div class="paragraph"><p><code>hara.io.scheduler</code> aims to provide an easy and intuitive way of specifying, testing and managing scheduled tasks. Much emphasis has been placed upon task management, the ability to inspect and kill running tasks as well as simulation, the ability to shorten time so that the scheduler can quickly run tests over and over again. These two features make for a very simple to use, but powerful package for dealing with cron-like tasks.</p><p>The library was originally developed as <a href='https://www.github.com/zcaudate/cronj'>cronj</a> but has now been included as part of the larger <a href='https://www.github.com/zcaudate/hara'>hara</a> codebase. The innards have been more clearly abstracted though building with <a href='hara-component.html'>hara.component</a>. Whilst the dependency on <a href='https://www.github.com/clj-time/clj-time'>clj-time</a> is now option. Another feature that has been added is the ability to control a task's execution model, done through building on top of <a href='https://github.com/zcaudate/hara/blob/master/src/hara/concurrent/procedure.clj'>concurrent.procedure</a>.</p></div></section><section class="section" id="other-libraries"><h3 class="section">1.3  &nbsp;&nbsp; Other Libraries</h3><div class="paragraph"><p><code>hara.io.scheduler</code> is just one of many scheduling libraries in the clojure world including:</p><ul><li><a href='https://github.com/overtone/at-at'>at-at</a></li><li><a href='https://github.com/james-henderson/chime'>chime</a></li><li><a href='https://github.com/kognate/clj-cronlike'>clj-cronlike</a></li><li><a href='http://www.sauronsoftware.it/projects/cron4j'>cron4j</a></li><li><a href='https://github.com/aredington/monotony'>monotony</a></li><li><a href='https://github.com/michaelklishin/quartzite'>quartzite</a></li><li><a href='https://github.com/AdamClements/schejulure'>schejulure</a></li></ul></div></section></section><section class="chapter" id="concepts-and-design"><h2 class="chapter">2  &nbsp;&nbsp; Concepts and Design</h2><div class="group"><div class="paragraph"><p><code>hara.io.scheduler</code> was built around a concept of a <strong>task</strong>. A task has two components:</p><ul><li>A <code>handler</code>  (what is to be done)</li><li>A <code>schedule</code> (when it should be done)</li></ul><p>Tasks are synchronized to run using a <code>clock</code>. If a task was scheduled to run at that time, it's <code>handler</code> would be run in a seperate thread. In this section, the general features and use cases for <code>hara.io.scheduler</code> will be shown as well as the novel ideas introduced in the library. These ideas will be exanded upon in the <a href='#walkthrough'>walkthrough</a>:</p></div></div><section class="section" id="seperation-of-concerns"><h3 class="section">2.1  &nbsp;&nbsp; Seperation of Concerns</h3><div class="paragraph"><p>A task handler is a function that can take up to three arguments:</p><ul><li><code>t</code>, the timestamp</li><li><code>params</code>, custom data associated with the task</li><li><code>instance</code>, options to change the execution model of the task</li></ul></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(fn [t params instance]
    (... perform a task ...))</div></div><div class="paragraph"><p><code>t</code> represents the time at which the handler was called. This solves the problem of <em>time synchronisation</em>. For example, I may have three tasks scheduled to run at a same time:</p><ul><li>perform a calculation and write the result to the database<ul><li>perform a http call and write result to the database</li><li>load some files, write to single output then store file location to the database.</li></ul></li></ul><p>All these tasks will end at different times. To retrospectively reasoning about how all three tasks were synced, each handler is required to accept the triggred time <code>t</code> as an argument.</p><p><code>params</code> is a hashmap, for example <code>{:path '/app/videos'}</code>. It has been found that user customisations such as server addresses and filenames, along with job schedules are usually specified at the top-most tier of the application whilst handler logic is usually in the middle-tier. Having an extra <code>opts</code> argument allow for better seperation of concerns and more readable code.</p><p><code>instance</code> is also a hashmap to manipulate whether to run the function synchronously or asynchronously, to access cached data, etc. More examples can be seen in the <a href='hara-concurrent-procedure.html'>procedure</a> docs.</p></div></section><section class="section" id="thread-management"><h3 class="section">2.2  &nbsp;&nbsp; Thread Management</h3><div class="paragraph"><p>Fully-featured thread management capabilities have been implemented:</p><ul><li>tasks can start at the next scheduled time before the previous thread has finished running so that multiple threads can be running simultaneously for a single task.</li><li>running threads can be listed.</li><li>normal and abnormal termination:<ul><li>kill a running thread</li><li>kill all running threads in a task</li><li>kill all threads</li><li>disable task but let running threads finish</li><li>stop timer but let running threads finish</li><li>shutdown timer, kill all running threads</li></ul></li></ul></div></section><section class="section" id="simulation-testing"><h3 class="section">2.3  &nbsp;&nbsp; Simulation Testing</h3><div class="paragraph"><p>Because the <code>clock</code> module is been completely decoupled from the task array it was very easy to add a simulation component into library. Simulation has some very handy features:</p><ul><li>Simulate how the entire system would behave over a long periods of time</li><li>Generating test inputs for other applications.</li><li>Both single and multi-threaded execution strategies are supported.</li></ul></div></section></section><section class="chapter" id="walkthrough"><h2 class="chapter">3  &nbsp;&nbsp; Walkthrough</h2><section class="section" id="creating-a-task"><h3 class="section">3.1  &nbsp;&nbsp; Creating a Task</h3><div class="paragraph"><p>We start off by defining a very basic function to essentially print what was passed to it:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn print-fn [t params]
  (println (:output params) &quot;:&quot; t))</div></div><div class="paragraph"><p> We define <code>print-task</code>, which adds schedule and custom param information:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def print-task
  {:handler print-fn
   :schedule &quot;/2 * * * * * *&quot;
   :params {:output &quot;Hello There&quot;}})</div></div><div class="paragraph"><p>We define the scheduler <code>sch</code> as having a single task:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch1 (scheduler {:print-task print-task}))</div></div><div class="paragraph"><p>Typically, we will read <code>:schedule</code> and <code>:params</code> from a config. In order to seperate code and data, there is an alternate two argument version that can be used for initialisation:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch1 (scheduler {:print-task print-fn}
                     {:print-task {:schedule &quot;/2 * * * * * *&quot;
                                   :params  {:output &quot;Hello There&quot;}}}))</div></div><div class="paragraph"><p>The seperation of function and data is suitable for writing code that looks like this:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch1 (scheduler {:print-task print-fn}
                    (&lt;load-config&gt; &quot;&lt;filename&gt;.edn&quot;)))</div></div><div class="paragraph"><p>Where <filename.edn> would contain the necessary information for <code>:schedule</code> and <code>:params</code></p></div></section><section class="section" id="starting-out"><h3 class="section">3.2  &nbsp;&nbsp; Starting out</h3><div class="paragraph"><p>So now we can start playing around with starting and stopping the scheduler:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(start! sch1)
;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:44.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:46.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:48.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:50.000-00:00&quot;

(stop! sch1) ;; OUTPUT STOPS</div></div></section><section class="section" id="components"><h3 class="section">3.3  &nbsp;&nbsp; Components</h3><div class="paragraph"><p>Note that because <code>start!</code> is really just a call to <code>component/start</code>, the following works as well:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch1 (component/start sch))
;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:44.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:46.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:48.000-00:00&quot;

... wait 2 secs ...

;; &gt; Hello There :  #inst &quot;2015-07-17T06:26:50.000-00:00&quot;

(def sch1 (component/stop sch)) ;; OUTPUT STOPS</div></div></section><section class="section" id="schedule"><h3 class="section">3.4  &nbsp;&nbsp; Schedule</h3><div class="paragraph"><p>Each task has a <code>:schedule</code> entry. The value is a string specifying when it is supposed to run. The string is of the same format as <code>crontab</code> -  seven elements seperated by spaces. The elements are used to match the time, expressed as seven numbers:</p><pre><code> second minute hour day-of-week day-of-month month year
</code></pre><p>The rules for a match between the crontab and the current time are:</p><ul><li><code>A</code>       means match on <code>A</code></li><li><code>&#42;</code>       means match on any number</li><li><code>E1,E2</code>   means match on both <code>E1</code> and <code>E2</code></li><li><code>A-B</code>     means match on any number between <code>A</code> and <code>B</code> inclusive</li><li><code>/N</code>      means match on any number divisible by <code>N</code></li><li><code>A-B/N</code>   means match on any number divisible by <code>N</code> between <code>A</code> and <code>B</code> inclusive</li></ul><p>Where <code>A</code>, <code>B</code> and <code>N</code> are numbers; <code>E1</code> and <code>E2</code> are expressions. All seven elements in the string have to match in order for the task to be triggered.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">;; Triggered every 5 seconds

&quot;/5 * * * * * *&quot;


;; Triggered every 5 seconds between 32 and 60 seconds

&quot;32-60/5 * * * * * *&quot;

;; Triggered every 5 seconds on the 9th aand 10th
;; minute of every hour on every Friday from June
;; to August between years 2012 to 2020.

&quot;/5  9,10  * 5 * 6-8 2012-2020&quot;</div></div></section></section><section class="chapter" id="simulation"><h2 class="chapter">4  &nbsp;&nbsp; Simulation</h2><div class="group"><div class="paragraph"><p>Simulations are a great way to check if the system is working correctly. This allows an entire system to be tested for correctness. How <code>simulate</code> works is that it decouples the <code>clock</code> from the task array and forces tasks to trigger on the range of date inputs provided.</p></div></div><section class="section" id="y2-k-revisited"><h3 class="section">4.1  &nbsp;&nbsp; Y2K Revisited</h3><div class="paragraph"><p>For instance, we wish to test that our <code>print-handler</code> method was not affected by the Y2K Bug. <code>T1</code> and <code>T2</code> are defined as start and end times:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def T1 #inst &quot;1999-12-31T23:59:50.00-00:00&quot;)
(def T2 #inst &quot;2000-01-01T00:00:10.00-00:00&quot;)</div></div><div class="paragraph"><p>The simulation is then run from <code>T1</code> to <code>T2</code> and the results are shown instantaneously</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(simulate sch1
          {:start T1
           :end   T2})
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:50.000-00:00&quot;
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:52.000-00:00&quot;
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:54.000-00:00&quot;
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:56.000-00:00&quot;
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:58.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:00.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:02.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:04.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:06.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:08.000-00:00&quot;</div></div><div class="paragraph"><p>We can control the way the simulation is run through other params</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(simulate sch1
          {:start T1
           :end   T2
           :mode  :async
           :pause 0
           :step  3})
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:56.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:02.000-00:00&quot;
;; &gt; Hello There : #inst &quot;2000-01-01T00:00:08.000-00:00&quot;
;; &gt; Hello There : #inst &quot;1999-12-31T23:59:50.000-00:00&quot;</div></div><div class="paragraph"><p><code>:mode</code> can be either <code>:sync</code> (default) or <code>:async</code>. <code>:step</code> is the number of second to wait to test again and pause is the sleep time in milliseconds.</p></div></section><section class="section" id="interval-and-pause"><h3 class="section">4.2  &nbsp;&nbsp; Interval and Pause</h3><div class="paragraph"><p>It can be seen that we can simulate the actual speed of outputs by keeping the step as 1 and increasing the pause time to 1000ms</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(simulate sch1
          {:start T1
           :end   T2
           :mode  :async
           :pause 1000
           :step  1})</div></div><section class="subsection" id="speeding-up"><h4 class="subsection">4.2.1  &nbsp;&nbsp; Speeding Up</h4><div class="paragraph"><p>In the following example, the step has been increased to 2 whilst the pause time has decreased to 100ms. This results in a 20x increase in the speed of outputs.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(simulate sch1
          {:start T1
           :end   T2
           :mode  :async
           :pause 100
           :step  2})

;; &gt; Hello There : #inst &quot;1999-12-31T23:59:50.000-00:00&quot;

;;            ... wait 0.1 seconds ...

;; &gt; Hello There : #inst &quot;1999-12-31T23:59:52.000-00:00&quot;

;;            ... wait 0.1 seconds ...

;; &gt; Hello There : #inst &quot;1999-12-31T23:59:54.000-00:00&quot;</div></div><div class="paragraph"><p>Being able to adjust these simulation parameters are really powerful testing tools and saves an incredible amount of time in development. For example, we can quickly test the year long output of a task that is scheduled to run once an hour very quickly by making the interval 3600 seconds and the pause time to the same length of time that the task takes to finish. Through simulations, task scheduling can now be tested and entire systems just got easier to manage and reason about.</p></div></section></section></section><section class="chapter" id="task-management"><h2 class="chapter">5  &nbsp;&nbsp; Task Management</h2><div class="group"><div class="paragraph"><p>The scheduler is a device that deals with change, and so itself should be able to deal with change. It is possible to disable/enable, add/remove, reschedule/reparametise tasks both when the scheduler is stopped and while it is running. Lets start off with an empty scheduler:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch2 (scheduler {}))
  
(start! sch2)

;; ... nothing should happen ...</div></div></div><section class="section" id="add-task"><h3 class="section">5.1  &nbsp;&nbsp; add-task</h3><div class="paragraph"><p>Because the scheduler has already started, we can use <code>add-task</code> to immediately get output:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(add-task sch2 :hello {:handler  (fn [t params] (println params))
                       :schedule &quot;/2 * * * * * *&quot;
                       :params {:data &quot;foo&quot;}})

;;&gt; {:data &quot;foo&quot;}

;;  ... wait 2 seconds ...

;;&gt; {:data &quot;foo&quot;}
  
;;  ... continue outputting {:data &quot;foo&quot;} every 2 seconds</div></div></section><section class="section" id="reschedule-task"><h3 class="section">5.2  &nbsp;&nbsp; reschedule-task</h3><div class="paragraph"><p>We can use <code>reschedule-task</code> to change the timing with which the task fires:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(reschedule-task sch2 :hello &quot;/5 * * * * * *&quot;)
  
;;&gt; {:data &quot;foo&quot;}

;;  ... wait 5 seconds ...

;;&gt; {:data &quot;foo&quot;}
  
;;  ... continue outputting {:data &quot;foo&quot;} every 5 seconds</div></div></section><section class="section" id="reparametise-task"><h3 class="section">5.3  &nbsp;&nbsp; reparametise-task</h3><div class="paragraph"><p>We can use <code>reparametise-task</code> to change the parameters that are associated with the task</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(reparametise-task sch2 :hello {:data &quot;bar&quot;})
  
;;&gt; {:data &quot;bar&quot;}

;;  ... wait 5 seconds ...

;;&gt; {:data &quot;bar&quot;}
  
;;  ... continue outputting {:data &quot;bar&quot;} every 5 seconds</div></div></section><section class="section" id="disable-task"><h3 class="section">5.4  &nbsp;&nbsp; disable-task</h3><div class="paragraph"><p>We can use <code>disable-task</code> to still keep the task in the array but to stop it from triggering:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(disable-task sch2 :hello)

;; ... output stops ...</div></div></section><section class="section" id="enable-task"><h3 class="section">5.5  &nbsp;&nbsp; enable-task</h3><div class="paragraph"><p>We can use <code>enable-task</code> to rengage a disabled task:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(enable-task sch2 :hello)
  
;;&gt; {:data &quot;bar&quot;}

;;  ... wait 5 seconds ...

;;&gt; {:data &quot;bar&quot;}
  
;;  ... continue outputting {:data &quot;bar&quot;} every 5 seconds</div></div></section><section class="section" id="delete-task"><h3 class="section">5.6  &nbsp;&nbsp; delete-task</h3><div class="paragraph"><p>Finally, we can use <code>delete-task</code> to remove the entry completely from the scheduler:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(delete-task sch2 :hello)
  
;; ... output stops ...</div></div></section><section class="section" id="empty-tasks"><h3 class="section">5.7  &nbsp;&nbsp; empty-tasks</h3><div class="paragraph"><p>Finally, we can use <code>empty-tasks</code> will clear all tasks from the scheduler</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(empty-tasks sch2)</div></div></section></section><section class="chapter" id="globals"><h2 class="chapter">6  &nbsp;&nbsp; Globals</h2><div class="group"><div class="paragraph"><p>Global settings are used to define the overall behaviour of the scheduler:</p></div></div><section class="section" id="defaults"><h3 class="section">6.1  &nbsp;&nbsp; Defaults</h3><div class="paragraph"><p>The global defaults are contained in <code>hara.io.scheduler/&#42;defaults&#42;</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(println hara.io.scheduler/*defaults*)
=&gt; {:clock {:type &quot;java.util.Date&quot;,
            :timezone &quot;Asia/Kolkata&quot;,
            :interval 1,
            :truncate :second},
    :registry {},
    :cache {},
    :ticker {}}</div></div><div class="paragraph"><p>For the purposes of the reader, only the <code>:clock</code> entry of <code>&#42;defaults&#42;</code> is important. To override the defaults, define the scheduler with the settings that needs to be customised. To set the time component used to be <code>java.time.Instant</code>, define the scheduler as follows:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch2 (scheduler {:hello {:handler  (fn [t params] (println t))
                              :schedule &quot;/2 * * * * * *&quot;
                              :params {}}}
                     {}
                     {:clock {:type &quot;java.time.Instant&quot;}}
                     ))

(start! sch2)
;;&gt; #&lt;Instant 2016-03-05T03:24:06Z&gt;

;;  ... wait 2 seconds ...
  
;;&gt; #&lt;Instant 2016-03-05T03:24:08Z&gt;

;;  ... printing out instances of java.time.Instant every 2 seconds ...
  
(stop! sch2)</div></div></section><section class="section" id="date-as-data"><h3 class="section">6.2  &nbsp;&nbsp; Date as data</h3><div class="paragraph"><p>It is also possible to use the clojure map representation (the default in hara.time)</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch2 (scheduler {:hello {:handler  (fn [t params] (println t))
                              :schedule &quot;/2 * * * * * *&quot;
                              :params {}}}
                     {}
                     {:clock {:type &quot;clojure.lang.PersistentArrayMap&quot;
                              :timezone &quot;GMT&quot;}}))
  
(start! sch2)

;;&gt; {:day 6, :hour 20, :timezone GMT, :second 38, :month 3,
;;   :type clojure.lang.PersistentHashMap, :year 2016, :millisecond 0, :minute 30}

;;  ... wait 2 seconds ...
  
;;&gt; {:day 6, :hour 20, :timezone GMT, :second 40, :month 3,
;;   :type clojure.lang.PersistentHashMap, :year 2016, :millisecond 0, :minute 30}
  
;;  ... printing out instances of java.time.Instant every 2 seconds ...
  
(stop! sch2)</div></div></section><section class="section" id="timezone"><h3 class="section">6.3  &nbsp;&nbsp; Timezone</h3><div class="paragraph"><p>Having a <code>:timezone</code> value in the clock will ensure that the right timezone is set. The default will always be the system local time, but it can be set to any timezone. To see this in effect, the <code>Calendar</code> object is used and EST is applied.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch2 (scheduler {:hello {:handler  (fn [t params] (println t))
                              :schedule &quot;/2 * * * * * *&quot;
                              :params {}}}
                     {}
                     {:clock {:type &quot;java.util.Calendar&quot;
                              :timezone &quot;EST&quot;}}))
  
(start! sch2)

;;&gt; #inst &quot;2016-03-06T15:37:38.000-05:00&quot;
  
;;  ... wait 2 seconds ...

;;&gt; #inst &quot;2016-03-06T15:37:40.000-05:00&quot;

;;  ... wait 2 seconds ...

;;&gt; #inst &quot;2016-03-06T15:37:42.000-05:00&quot;

(stop! sch2)</div></div></section></section><section class="chapter" id="realtime-management"><h2 class="chapter">7  &nbsp;&nbsp; Realtime Management</h2><div class="group"><div class="paragraph"><p>In previous sections, we only looked at tasks that finishes instantaneously. In most cases, this will not be the case. Triggered tasks may run for a long time, and sometimes triggered tasks may overlap (for example, the first task instance may still be running when the second task instance is triggered). Facilities for inspecting what tasks are running as well as to be able to stop running instances of the tasks are needed. Task management capabilities are demonstrated by first creating two task entries labeled <code>l1</code> and <code>l2</code> doing nothing but sleeping for a long time:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch2
  (scheduler {:l1 {:handler  (fn [t params] (Thread/sleep 30000000000000))
                   :schedule &quot;/2 * * * * * *&quot;
                   :params {:data &quot;foo&quot;}}
              :l2 {:handler  (fn [t params] (Thread/sleep 30000000000000))
                   :schedule &quot;/2 * * * * * *&quot;
                   :params {:data &quot;bar&quot;}}}))</div></div></div><section class="section" id="trigger"><h3 class="section">7.1  &nbsp;&nbsp; trigger!</h3><div class="paragraph"><p>We can manually start a task using <code>trigger!</code> and a key:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(trigger! sch2 :l1 :first-run)</div></div><div class="paragraph"><p>And then look at the running instances:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(list-instances sch2 :l1)
;; =&gt; (#proc[:first-run]{:args (:run {:data &quot;foo&quot;}),
;;                       :name :l1, :mode :async,
;;                       :params {:data &quot;foo&quot;}, :result :waiting,
;;                       :runtime {:started #inst &quot;2015-07-17T07:37:10.818-00:00&quot;},
;;                       :interrupt false,
;;                       :input (:run {:data &quot;foo&quot;} {}),
;;                       :timestamp :run})</div></div><div class="paragraph"><p>Using a key is good for when you just want one instance to run at a time, calling it a second time will not start another process</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(trigger! sch2 :l1 :first-run)
(count (list-instances sch2 :l1))
=&gt; 1</div></div><div class="paragraph"><p>Calling <code>trigger!</code> with a different key will start another process:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(trigger! sch2 :l1 :second-run)
(count (list-instances sch2 :l1))
=&gt; 2</div></div><div class="paragraph"><p>Calling <code>trigger!</code> without a key will use the current timestamp. </p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(trigger! sch2 :l1)
;; =&gt; #proc[Fri Jul 17 13:15:59 IST 2015]
;;      {:args (#inst &quot;2015-07-17T07:45:59.464-00:00&quot; {:data &quot;foo&quot;}),
;;       :name :l1, :mode :async, :params {:data &quot;foo&quot;},
;;       :result :waiting,
;;       :runtime {:started #inst &quot;2015-07-17T07:45:59.464-00:00&quot;},
;;       :interrupt false,
;;       :input (#inst &quot;2015-07-17T07:45:59.464-00:00&quot; {:data &quot;foo&quot;} {}),
;;       :timestamp #inst &quot;2015-07-17T07:45:59.464-00:00&quot;}
(Thread/sleep 10)
(count (list-instances sch2 :l1))
=&gt; 3</div></div></section><section class="section" id="list-and-kill"><h3 class="section">7.2  &nbsp;&nbsp; List and kill</h3><div class="paragraph"><p>We can kill them individually using <code>kill-instance</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(kill-instance sch2 :l1 :first-run)
=&gt; true

(count (list-instances sch2 :l1))
=&gt; 2</div></div><div class="paragraph"><p>We can kill all instances of a particular task using <code>kill-instances</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(kill-instances sch2 :l1)
=&gt; [true true]

(count (list-instances sch2 :l1))
=&gt; 0</div></div><div class="paragraph"><p>We can kill all running instances of all tasks within a scheduler with <code>kill-all</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(trigger! sch2 :l1)
(Thread/sleep 100)
(trigger! sch2 :l1)
(Thread/sleep 100)
(trigger! sch2 :l1)

(trigger! sch2 :l2)
(Thread/sleep 100)
(trigger! sch2 :l2)
(Thread/sleep 100)
(trigger! sch2 :l2)
(Thread/sleep 100)

(count (list-instances sch2 :l1))
=&gt; 3

(count (list-instances sch2 :l2))
=&gt; 3

(kill-all sch2)

(count (list-instances sch2 :l1))
=&gt; 0

(count (list-instances sch2 :l2))
=&gt; 0</div></div></section><section class="section" id="realtime-demo"><h3 class="section">7.3  &nbsp;&nbsp; Realtime demo</h3><div class="paragraph"><p>To show some of these methods in action, we will call these methods on a running scheduler:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(start! sch2)


... wait a moment and see how many instances are running...

(count (list-instances sch2 :l1))
=&gt; 10

... wait and check again ...

(count (list-instances sch2))
=&gt; 44

... and again ...

(count (list-instances sch2))
=&gt; 145

... okay that's too many threads being generated ...

(stop! sch2)

... stop! doesn't kill the instances that are already running ...

(count (list-instances sch2))
=&gt; 145

... so we have to kill them manually ...

(kill-all sch2)
=&gt; [true true true true
    ...
    ...
    true true true true true]

(count (list-instances sch2))
=&gt; 0</div></div></section><section class="section" id="shutdown-and-restart"><h3 class="section">7.4  &nbsp;&nbsp; Shutdown and Restart</h3><div class="paragraph"><p>To show the difference between <code>shutdown!</code> and <code>stop!</code>, lets start up the scheduler again and call <code>shutdown!</code> first:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(start! sch2)
  
... and again we wait ...

(count (list-instances sch2))
=&gt; 10

... we now have instances running ...

(shutdown! sch2)

... after the call, we notice that there are no running istances ...

(count (list-instances sch2))
=&gt; 0</div></div><div class="paragraph"><p>Now, lets try the same thing with <code>stop!</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(start! sch2)
  
... and again we wait ...

(count (list-instances sch2))
=&gt; 10

... we now have instances running ...

(stop! sch2)

... after the call, we notice that there are still running instances ...

(count (list-instances sch2))
=&gt; 10</div></div><div class="paragraph"><p><code>restart!</code>, like <code>shutdown!</code> also kills all running instances but then calls <code>start!</code> again</p></div></section></section><section class="chapter" id="api"><h2 class="chapter">8  &nbsp;&nbsp; API</h2><div class="group"><div class="api"><hr /><div><a name="api-hara-io-scheduler"></a><h4><i>API</i></h4><a href="#api-hara-io-scheduler--add-task">add-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--create">create</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--delete-task">delete-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--disable-task">disable-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--empty-tasks">empty-tasks</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--enable-task">enable-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--get-task">get-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--kill-all">kill-all</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--kill-instance">kill-instance</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--kill-instances">kill-instances</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--list-instances">list-instances</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--list-tasks">list-tasks</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--reparametise-task">reparametise-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--reschedule-task">reschedule-task</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--restart!">restart!</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--running?">running?</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--scheduler">scheduler</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--shutdown!">shutdown!</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--simulate">simulate</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--start!">start!</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--stop!">stop!</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--stopped?">stopped?</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--trigger!">trigger!</a>&nbsp;&nbsp;<a href="#api-hara-io-scheduler--uptime">uptime</a>&nbsp;&nbsp;</div><hr /><div><div><a name="api-hara-io-scheduler--add-task"></a><h4>add-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;add a task to the scheduler&quot;
(add-task (scheduler {})
          :hello {:handler (fn [t params] (println params))
                  :schedule &quot;* * * * * * *&quot;
                  :params {:data &quot;foo&quot;}})</div></div><div><a name="api-hara-io-scheduler--create"></a><h4>create <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;function for use with the component framework.&quot;</div></div><div><a name="api-hara-io-scheduler--delete-task"></a><h4>delete-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;deletes a specific task in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--disable-task"></a><h4>disable-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;disables a specific task in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--empty-tasks"></a><h4>empty-tasks <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;clears all tasks in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--enable-task"></a><h4>enable-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;enables a specific task in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--get-task"></a><h4>get-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;retruns a specific task in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--kill-all"></a><h4>kill-all <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;kills all instances of all tasks in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--kill-instance"></a><h4>kill-instance <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;kills a single instance of the running task&quot;</div></div><div><a name="api-hara-io-scheduler--kill-instances"></a><h4>kill-instances <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;kills all instances of the running task&quot;</div></div><div><a name="api-hara-io-scheduler--list-instances"></a><h4>list-instances <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;lists all running instances of a tasks in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--list-tasks"></a><h4>list-tasks <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;lists all tasks in the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--reparametise-task"></a><h4>reparametise-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;changes the schedule for an already existing task&quot;
(-&gt; (scheduler {:hello {:handler (fn [t params] (println params))
                                       :schedule &quot;* * * * * * *&quot;
                        :params {:data &quot;foo&quot;}}})
    (reparametise-task :hello {:data &quot;bar&quot;}))</div></div><div><a name="api-hara-io-scheduler--reschedule-task"></a><h4>reschedule-task <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;changes the schedule for an already existing task&quot;
(-&gt; (scheduler {:hello {:handler (fn [t params] (println params))
                                     :schedule &quot;* * * * * * *&quot;
                        :params {:data &quot;foo&quot;}}})
    (reschedule-task :hello &quot;/5 * * * * * *&quot;))</div></div><div><a name="api-hara-io-scheduler--restart!"></a><h4>restart! <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;restarts the scheduler after a forced shutdown&quot;</div></div><div><a name="api-hara-io-scheduler--running?"></a><h4>running? <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;checks to see if the scheduler is running&quot;</div></div><div><a name="api-hara-io-scheduler--scheduler"></a><h4>scheduler <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;creates a schedular from handlers, or both handlers and config&quot;</div></div><div><a name="api-hara-io-scheduler--shutdown!"></a><h4>shutdown! <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;forcibly shuts down the scheduler, immediately killing all running threads&quot;</div></div><div><a name="api-hara-io-scheduler--simulate"></a><h4>simulate <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;simulates the scheduler running for a certain interval:&quot;

(simulate
 (scheduler {:print-task {:handler (fn [t params instance]
                                     (str t params))
                          :schedule &quot;/2 * * * * * *&quot;
                          :params   {:value &quot;hello world&quot;}}})
 {:start (java.util.Date. 0)
  :end   (java.util.Date. 100000)
  :pause 10})</div></div><div><a name="api-hara-io-scheduler--start!"></a><h4>start! <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;starts the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--stop!"></a><h4>stop! <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;stops the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--stopped?"></a><h4>stopped? <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;checks to see if the scheduler is stopped&quot;</div></div><div><a name="api-hara-io-scheduler--trigger!"></a><h4>trigger! <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;manually executes a task, bypassing the scheduler&quot;</div></div><div><a name="api-hara-io-scheduler--uptime"></a><h4>uptime <a href="#api-hara-io-scheduler">&#9652;</a></h4><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;checks to see how long the scheduler has been running&quot;</div></div></div></div></div></section><section class="chapter" id="cronj"><h2 class="chapter">9  &nbsp;&nbsp; Cronj</h2><section class="section" id="upgrade"><h3 class="section">9.1  &nbsp;&nbsp; Upgrade</h3><div class="paragraph"><p><a href='https://github.com/zcaudate/cronj'>cronj</a> was the original scheduling library before the concept became absorbed into the larger <a href='https://docs.caudate.me/hara'>hara</a> ecosystem and the <code>hara.ion.scheduler</code> library was born. Although there was a significant cleanup of the internal components within the scheduler, the architecture has not really changed at all. Most of the original cronj methods have been kept pretty much the same so it should be very quick to move from one to the other.</p><p><a href='https://github.com/zcaudate/cronj'>cronj</a> uses <a href='https://github.com/clj-time/clj-time'>clj-time</a>, a wrapper around <a href='http://www.joda.org/joda-time/'>joda-time</a> to provide for time manipulation. The library has been swapped out in favor of <code>hara.time</code> because it provides a more flexible option.</p><p><code>hara.io.scheduler</code> allows the user to select from a few different time implementations and so while new projects can start with the new <code>java.time.Instant</code> entry, or even the clojure map representation of time. However, many projects will still be working with <a href='http://www.joda.org/joda-time/'>joda-time</a> and this has been supported through another project - <a href='https://github.com/zcaudate/hara.time.joda'>hara.time.joda</a>, which provides joda-time extensions to <code>hara.time</code>.</p></div><div class="paragraph"><p>To upgrade to <code>cronj</code> to <code>hara.io.scheduler</code>, all that needs to be done is to add to <code>project.clj</code> dependencies:  </p><pre><code>&#91;im.chit/hara.io.scheduler &quot;2.3.0&quot;&#93;
&#91;im.chit/hara.time.joda    &quot;2.3.0&quot;&#93;
</code></pre><p>Apart from the initial call to include the scheduler, require the <code>hara.time.joda</code> namespace to load in all the protocol and multimethod hooks.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(require '[hara.io.scheduler :refer :all])
(require '[hara.time.joda])</div></div></section><section class="section" id="constructor"><h3 class="section">9.2  &nbsp;&nbsp; Constructor</h3><div class="paragraph"><p>Most of the methods have been kept pretty much the same, except the constructor. The previous way of constructing the scheduler looks like this:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(require '[cronj.core :as cj])
(def cnj (cj/cronj
          :interval 2
          :entries [{:id       :t1
                     :handler  (fn [dt opts] (println dt) (Thread/sleep 1000))
                     :schedule &quot;* * * * * * *&quot;
                     :enabled  true
                     :opts     {:home &quot;/home/cronj&quot;}}
                    
                    {:id       :t2
                     :handler  (fn [dt opts] (println dt) (Thread/sleep 5000))
                     :schedule &quot;* * * * * * *&quot;
                     :enabled  true
                     :opts     {:ex &quot;example&quot;}}]))</div></div><div class="paragraph"><p>Now it looks like this:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(require '[hara.io.scheduler :as sch])
(def sch (sch/scheduler
          {:t1 {:handler (fn [t params] (println dt) (Thread/sleep 1000))
                :schedule &quot;* * * * * * *&quot;
                :params   {:home &quot;/home/cronj&quot;}}
           :t2 {:handler (fn [t params] (println dt) (Thread/sleep 5000))
                :schedule &quot;* * * * * * *&quot;
                :params   {:ex &quot;example&quot;}}}
          {}
          {:clock {:type &quot;org.joda.time.DateTime&quot;
                   :interval 2}}))</div></div><div class="paragraph"><p>Or for the seperation of config and function, as well as simplification of the interface, it can also look like this:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def sch (sch/scheduler
          {:t1 (fn [t] (println t) (Thread/sleep 1000))
           :t2 (fn [t] (println t) (Thread/sleep 5000))}
          {:t1 {:schedule &quot;* * * * * * *&quot;
                :params   {:home &quot;/home/cronj&quot;}}
           :t2 {:schedule &quot;* * * * * * *&quot;
                :params   {:ex &quot;example&quot;}}}
          {:clock {:type &quot;org.joda.time.DateTime&quot;
                   :interval 2}}))
(sch/start! sch)

  
;;&gt;#&lt;DateTime 2016-03-07T07:47:04.000+05:30&gt;
;;&gt;#&lt;DateTime 2016-03-07T07:47:04.000+05:30&gt;


;;&gt;#&lt;DateTime 2016-03-07T07:47:05.000+05:30&gt;
;;&gt;#&lt;DateTime 2016-03-07T07:47:05.000+05:30&gt;

;;&gt;#&lt;DateTime 2016-03-07T07:47:06.000+05:30&gt;
;;&gt;#&lt;DateTime 2016-03-07T07:47:06.000+05:30&gt;
  
(sch/stop! sch)</div></div><div class="paragraph"><p>The upgrade is complete.</p></div></section></section><section class="chapter" id="links-and-resources"><h2 class="chapter">10  &nbsp;&nbsp; Links and Resources</h2><div class="group"><div class="paragraph"><p>Here are some more links and resources on the web:</p><ul><li><a href='http://z.caudate.me/immutability-time-and-task-schedulers/'>immutability, time and testable task schedulers</a> - original article on the philosophy behind <a href='http://www.github.com/zcaudate/cronj'>cronj</a></li></ul></div></div></section>
    </div>
</div><!--end of .container-->

  <section class="application">
    
  </section>
</body>

<script>
  $('#nav').affix({
    offset: {
        top: $('#nav').offset().top,
        bottom: $('footer').outerHeight(true) + $('.application').outerHeight(true) + 40
    }});
</script>


<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</body>
</html>
