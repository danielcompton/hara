

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <meta name="google" value="notranslate">


    <title>event</title>

    
  <link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/clojure.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/magula.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.2/angular.min.js"></script>
  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular-cookies.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.13.0/ui-bootstrap-tpls.min.js"></script>
  <script type="text/javascript" src="js/angular-highlightjs.min.js"></script>

  <link rel="stylesheet" type="text/css" href="css/rdash.min.css">
  <link rel="stylesheet" type="text/css" href="css/scrollspy.css">


  <script>
    window.console = window.console || function(t) {};
    window.open = function(){ console.log("window.open is disabled."); };
    window.print   = function(){ console.log("window.print is disabled."); };
  </script>

  <script>
    var app = angular.module('app', ['hljs']);
  </script>
  </head>

  <body ng-app="app" data-spy="scroll" data-target=".scrollspy">
  <!-- Fixed navbar -->
    <nav class="navbar navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html"><img src="img/logo.png"></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Guides <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="hara-class.html">class</a></li>
                <li><a href="hara-common.html">common</a></li>
                <li><a href="hara-component.html">component</a></li>
                <li><a href="hara-concurrent.html">concurrent</a></li>
                <li><a href="hara-concurrent-ova.html">concurrent.ova</a></li>
                <li><a href="hara-concurrent-procedure.html">concurrent.procedure</a></li>
                <li><a href="hara-data.html">data</a></li>
                <li><a href="hara-event.html">event</a></li>
                <li><a href="hara-expression.html">expression</a></li>
                <li><a href="hara-extend.html">extend</a></li>
                <li><a href="hara-function.html">function</a></li>
                <li><a href="hara-group.html">group</a></li>
                <li><a href="hara-io-environment.html">io.environment</a></li>
                <li><a href="hara-io-scheduler.html">io.scheduler</a></li>
                <li><a href="hara-io-watch.html">io.watch</a></li>
                <li><a href="hara-namespace.html">namespace</a></li>
                <li><a href="hara-object.html">object</a></li>
                <li><a href="hara-reflect.html">reflect</a></li>
                <li><a href="hara-sort.html">sort</a></li>
                <li><a href="hara-string.html">string</a></li>
                <li><a href="hara-time.html">time</a></li>
            </ul>
            </li>
            <li>
              <a href="https://github.com/zcaudate/hara" target="_blank">Github</a></li>
            <li>
              <a href="http://gitter.im/zcaudate/hara" target="_blank">Gitter</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


  <div class="container row">
    <div class="col-md-4 scrollspy pull-right">
      <ul id="nav" class="nav hidden-xs hidden-sm" data-spy="affix">
        <li><a href="#introduction">1  &nbsp;&nbsp; Introduction</a><ul class="nav"><li><a href="#installation">1.1  &nbsp;&nbsp; Installation</a></li><li><a href="#motivation">1.2  &nbsp;&nbsp; Motivation</a></li><li><a href="#other-libraries">1.3  &nbsp;&nbsp; Other Libraries</a></li></ul></li><li><a href="#event-management">2  &nbsp;&nbsp; Event Management</a><ul class="nav"><li><a href="#listeners-and-managers">2.1  &nbsp;&nbsp; Listeners and Managers</a></li><li><a href="#listener-syntax">2.2  &nbsp;&nbsp; Listener Syntax</a></li><li><a href="#signal-syntax">2.3  &nbsp;&nbsp; Signal Syntax</a></li><li><a href="#raise-syntax">2.4  &nbsp;&nbsp; Raise Syntax</a></li><li><a href="#manage-syntax">2.5  &nbsp;&nbsp; Manage Syntax</a></li></ul></li><li><a href="#quickstart">3  &nbsp;&nbsp; Quickstart</a><ul class="nav"><li><a href="#unlucky-numbers">3.1  &nbsp;&nbsp; Unlucky Numbers</a></li><li><a href="#getting-messy">3.2  &nbsp;&nbsp; Getting Messy</a></li><li><a href="#raise-dont-throw">3.3  &nbsp;&nbsp; Raise, don't Throw</a></li><li><a href="#issues-and-abnormal-flow">3.4  &nbsp;&nbsp; Issues and Abnormal Flow</a></li><li><a href="#a-sleight-of-hand">3.5  &nbsp;&nbsp; A Sleight of Hand</a></li><li><a href="#chinese-unlucky-numbers">3.6  &nbsp;&nbsp; Chinese Unlucky Numbers</a></li><li><a href="#christian-unlucky-numbers">3.7  &nbsp;&nbsp; Christian Unlucky Numbers</a></li></ul></li><li><a href="#api">4  &nbsp;&nbsp; API</a><ul class="nav"><li><a href="#api-raise">4.1  &nbsp;&nbsp; raise</a></li><li><a href="#option--default">4.2  &nbsp;&nbsp; option/default</a></li><li><a href="#manage--on">4.3  &nbsp;&nbsp; manage/on</a></li><li><a href="#checkers">4.4  &nbsp;&nbsp; checkers</a></li><li><a href="#bindings">4.5  &nbsp;&nbsp; bindings</a></li><li><a href="#catch-and-finally">4.6  &nbsp;&nbsp; catch and finally</a></li><li><a href="#special-forms">4.7  &nbsp;&nbsp; special forms</a></li><li><a href="#api-continue">4.8  &nbsp;&nbsp; continue</a></li><li><a href="#api-fail">4.9  &nbsp;&nbsp; fail</a></li><li><a href="#api-choose">4.10  &nbsp;&nbsp; choose</a></li><li><a href="#api-default">4.11  &nbsp;&nbsp; default</a></li><li><a href="#api-escalate">4.12  &nbsp;&nbsp; escalate</a></li></ul></li><li><a href="#strategies">5  &nbsp;&nbsp; Strategies</a><ul class="nav"><li><a href="#normal">5.1  &nbsp;&nbsp; Normal</a></li><li><a href="#catch">5.2  &nbsp;&nbsp; Catch</a></li><li><a href="#continue">5.3  &nbsp;&nbsp; Continue</a></li><li><a href="#choose">5.4  &nbsp;&nbsp; Choose</a></li><li><a href="#choose-more">5.5  &nbsp;&nbsp; Choose - More Strategies</a></li><li><a href="#escalate">5.6  &nbsp;&nbsp; Escalate</a></li><li><a href="#fail">5.7  &nbsp;&nbsp; Fail</a></li><li><a href="#default">5.8  &nbsp;&nbsp; Default</a></li><li><a href="#on-form">5.9  &nbsp;&nbsp; Branch Using On</a></li></ul></li><li><a href="#implementation">6  &nbsp;&nbsp; Implementation</a><ul class="nav"><li><a href="#the-dumb-throw">6.1  &nbsp;&nbsp; The dumb throw</a></li><li><a href="#the-smart-raise">6.2  &nbsp;&nbsp; The smart raise</a></li><li><a href="#being-proactive">6.3  &nbsp;&nbsp; Being Proactive</a></li><li><a href="#the-issue-management-board">6.4  &nbsp;&nbsp; The Issue Management Board</a></li><li><a href="#control-flow-as-data">6.5  &nbsp;&nbsp; Control Flow as Data</a></li><li><a href="#implementing-catch">6.6  &nbsp;&nbsp; Implementing Catch</a></li><li><a href="#implementing-choose">6.7  &nbsp;&nbsp; Implementing Choose</a></li><li><a href="#implementing-the-rest">6.8  &nbsp;&nbsp; Implementing the Rest</a></li></ul></li><li><a href="#links-and-resources">7  &nbsp;&nbsp; Links and Resources</a></li>
      </ul>
    </div>
    <div class="col-md-8" id="content">
      <div class="jumbotron">
        <div class="container">
          <h1>event</h1>
          <h4>event signalling and conditional restart</h4>
        </div>
      </div>
      <section class="chapter" id="introduction"><h2 class="chapter">1  &nbsp;&nbsp; Introduction</h2><div class="group"><div class="paragraph"><p><a href='https://github.com/zcaudate/hara/blob/master/src/hara/event.clj'>hara.event</a> aims to provide more loosely coupled code through two mechanisms:</p><ul><li>a global eventing system for decoupilng of side-effecting</li><li>a conditional restart framework that hooks into the eventing system.</li></ul><p><code>hara.event</code> was originally developed as a <a href='https://github.com/zcaudate/ribol'>seperate library</a> but has been included as part of the larger <a href='https://github.com/zcaudate/hara'>hara</a> codebase. The main addition to the original library has been the inclusion of the eventing system as it was felt that there should be an integrated way of dealing with side-effecting calls such as logging, indexing, emails and many other tasks within both normal and abnormal program flows.</p></div></div><section class="section" id="installation"><h3 class="section">1.1  &nbsp;&nbsp; Installation</h3><div class="paragraph"><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;im.chit/hara.event &quot;2.2.17&quot;&#93;
</code></pre></div><div class="paragraph"><p>All functionality is found contained in the <code>hara.event</code> namespace</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(use 'hara.event)</div></div></section><section class="section" id="motivation"><h3 class="section">1.2  &nbsp;&nbsp; Motivation</h3><div class="paragraph"><p>For those that are not familiar with restart systems (most well know in Common Lisp), they can be thought of as an issue resolution system or <code>try++/catch++</code>. In <code>hara.event</code>, we use the term <code>issues</code> to differentiate them from <code>exceptions</code>. The difference is purely semantic: <code>issues</code> are <code>managed</code> whilst <code>exceptions</code> are <code>caught</code>. They all refer to abnormal program flow.</p><p>There are two forms of <code>exceptions</code> that a programmer will typically encounter:</p><ol><li><strong>Programming Mistakes</strong> - These are a result of logic and reasoning errors, should not occur in normal operation and should be eliminated as soon as possible. The best strategy for dealing with this is to use offensive checks such as pre- and post- conditions, write unit tests and have functions fail early with a clear message to the programmer about the error. Typical cases are:<ul><li>Null pointer exceptions</li><li>Wrong inputs to functions</li></ul></li><li><strong>Exceptions due to Circumstances</strong> - These are circumstancial and should be considered part of the normal operation of the program. There are a wide variety of such exceptions and usually is up to the programming workflow to handle such cases:<ul><li>A database connection going down</li><li>A file not found</li><li>User input not valid</li></ul></li></ol></li></ol><p>The method of <code>try</code> and <code>catch</code> exception handing, though commonly used and familiar to most programmers is a very weak system for exception handling. The try blocks are not really needed when dealing with the <em>Type 1</em> exceptions and a little too weak when dealing with those of <em>Type 2</em>. The net effect of using only the <code>try/catch</code> paradigm in application code is that in order to mitigate these <em>Type 2</em> exceptions, there requires a lot of defensive programming. This turns the middle level of the application into spagetti code with program control flow (<code>try/catch</code>) mixed in with program logic.</p><p>Conditional restarts provide a way for the top-level application to more cleanly deal with <em>Type 2</em> exceptions. A simple use case looking at advantages in using restarts over exceptions can be seen in the <a href='#quickstart'>quickstart</a>. For those that wish to know more about conditional restarts, there is a comprehensive <a href='#strategies'>strategies</a> chapter to the listing different ways abnormal program flow can be dealt with. For those curious about how the framework has been implementated, please jump over to the <a href='#implementation'>implementation</a> chapter.</p></div></section><section class="section" id="other-libraries"><h3 class="section">1.3  &nbsp;&nbsp; Other Libraries</h3><div class="paragraph"><p>There are currently three other conditional restart libraries for clojure, in the more traditional Common Lisp style syntax:</p><ul><li><a href='https://github.com/richhickey/clojure-contrib/blob/master/src/main/clojure/clojure/contrib/error&#95;kit.clj'>errorkit</a> was the first and provided the guiding architecture for this library.</li><li><a href='https://github.com/hugoduncan/swell'>swell</a> and <a href='https://github.com/bwo/conditions'>conditions</a> have been written to work with <a href='https://github.com/scgilardi/slingshot'>slingshot</a>.</li></ul></div></section></section><section class="chapter" id="event-management"><h2 class="chapter">2  &nbsp;&nbsp; Event Management</h2><section class="section" id="listeners-and-managers"><h3 class="section">2.1  &nbsp;&nbsp; Listeners and Managers</h3><div class="paragraph"><p>In any program, we see the following patterns</p><ul><li>side effects occur within both abnormal and normal program flow (usually logging)</li><li>side-effecting libraries coupled to the main logic (logback, email systems, alerts)</li><li>usually some sort of logging has to be done on abnormal program flow</li></ul><p><code>hara.event</code> provides for listeners and managers:</p><ul><li>Listeners act on events they have jurisdiction over for both <code>signal</code> and <code>raise</code> calls. All listeners participate.</li><li>Managers act in a hierarchical fashion where if an issue is raised, the closest manager will handle the issue.</li></ul><p>An example is provided below:</p></div><div class="figure"><a name="example-pathways"></a><div class="img"><img src="img/hara_event/event_pathway.png" width="100%" /></div><h4><i>fig.1  &nbsp;-&nbsp; example pathways</i></h4></div><div class="paragraph"><p>The only difference between <code>signal</code> and <code>raise</code> calls is that <code>signal</code> does not trigger <code>manage</code> handlers. Both calls will trigger any compatible listener. The listers and managers act in a horizontal/vertical or only/all fashion to provide for better decoupilng of functionality within the code base.</p></div></section><section class="section" id="listener-syntax"><h3 class="section">2.2  &nbsp;&nbsp; Listener Syntax</h3><div class="paragraph"><p><code>deflistener</code> installs a signal listener with a precondition for activation. For example, in the case below, if there is a <code>:log</code> in body of the signalled (or raised) event, then <code>event</code> will be printed.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(deflistener print-listener :log
  event
  (println event))</div></div></section><section class="section" id="signal-syntax"><h3 class="section">2.3  &nbsp;&nbsp; Signal Syntax</h3><div class="paragraph"><p><code>signal</code> typically just informs its listeners with a given set of information:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(signal {:everything-is-good true :input-data 3 :log true})</div></div><div class="paragraph"><p>If the previous <code>deflistener</code> was defined, then this call will activate a print statement.</p></div></section><section class="section" id="raise-syntax"><h3 class="section">2.4  &nbsp;&nbsp; Raise Syntax</h3><div class="paragraph"><p>Instead of <code>throw</code>, a new form <code>raise</code> is introduced (<a href='#raise-syntax'>e.2.4</a>):</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(raise {:input-not-string true :input-data 3}     ;; issue payload
       (option :use-na [] &quot;NA&quot;)                   ;; option 1
       (option :use-custom [n] n)                 ;; option 2
       (default :use-custom &quot;nil&quot;))               ;; default choice</div></div><div class="paragraph"><p><code>raise</code> differs to <code>throw</code> in a few ways:</p><ul><li>issues are of type <code>clojure.lang.ExceptionInfo</code>.</li><li>the payload is a <code>hash-map</code>.</li><li><strong>optional</strong>: multiple <code>option</code> handlers can be specified.</li><li><strong>optional</strong>: a <code>default</code> choice can be specified.</li></ul></div></section><section class="section" id="manage-syntax"><h3 class="section">2.5  &nbsp;&nbsp; Manage Syntax</h3><div class="paragraph"><p>Instead of the <code>try/catch</code> combination, <code>manage/on</code> is used (<a href='#manage-syntax'>e.2.5</a>).</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage (complex-operation)
        (on :node-working [node-name]
            (choose :wait-for-node))
        (on :node-failed [node-name]
            (choose :reinit-node))
        (on :database-down []
            (choose :use-database backup-database))
        (on :core-failed []
            (terminate-everything)))</div></div><div class="paragraph"><p>Issues are managed through <code>on</code> handlers within a <code>manage</code> block. If any <code>issue</code> is raised with the manage block, it is passed to each handler. There are six ways that a handler can deal with a raised issue:</p><ul><li>directly (same as <code>try/catch</code>)</li><li>using <code>continue</code> to keep going with a given value</li><li>using <code>choose</code> to specify an option</li><li>using <code>escalate</code> to notify higher level managers</li><li>using <code>default</code> to allow the issue to resolve itself</li><li>using <code>fail</code> to throw an exception</li></ul><p>Using these six different different issue resolution directives, the programmer has the richness of language to craft complex process control flow strategies without mixing logic handling code in the middle tier. Restarts can also create new ways of thinking about the problem beyond the standard <code>throw/catch</code> mechanism and offer more elegant ways to build programs and workflows.</p></div></section></section><section class="chapter" id="quickstart"><h2 class="chapter">3  &nbsp;&nbsp; Quickstart</h2><section class="section" id="unlucky-numbers"><h3 class="section">3.1  &nbsp;&nbsp; Unlucky Numbers</h3><div class="paragraph"><p>In this demonstration, we look at how code bloat problems using <code>throw/try/catch</code> could be reduced using <code>raise/manage/on</code>. Two functions are defined:</p><ul><li><code>check-unlucky</code> which takes a number as input, throwing a <code>RuntimeException</code> when it sees an unlucky number.</li><li><code>int-to-str</code> which calls <code>check-unlucky</code>, pretends to do work and outputs a string represention of the number.</li></ul></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn check-unlucky [n]
  (if (#{4 13 14 24 666} n)
    (throw (RuntimeException. &quot;Unlucky Number&quot;))
    n))

(defn int-to-str [n]
  (do (Thread/sleep 10)  ;; Work out something
      (str (check-unlucky n))))</div></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(int-to-str 1) =&gt; &quot;1&quot;

(int-to-str 666) =&gt; (throws RuntimeException &quot;Unlucky Number&quot;)</div></div><div class="paragraph"><p>We can then use <code>int-to-str</code> to run across multiple numbers:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(mapv int-to-str (range 4))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot;]</div></div></section><section class="section" id="getting-messy"><h3 class="section">3.2  &nbsp;&nbsp; Getting Messy</h3><div class="paragraph"><p>Except when we try to use it in with a sequence containing an unlucky number</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(mapv int-to-str (range 20))
=&gt; (throws RuntimeException &quot;Unlucky Number&quot;)</div></div><div class="paragraph"><p>We can try and recover using <code>try/catch</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(try
  (mapv int-to-str (range 20))
  (catch RuntimeException e
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</div></div><div class="paragraph"><p>But we can never get the previous sequence back again because we have blown the stack. The only way to 'fix' this problem is to change <code>int-to-str</code> so that it catches the exception:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn int-to-str-fix [n]
  (try
    (if (check-unlucky n)    ;;
      (do (Thread/sleep 10)  ;; Work out something
          (str n)))
    (catch RuntimeException e
      &quot;-&quot;)))

(mapv int-to-str-fix (range 20))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;-&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot;
    &quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;-&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot;]</div></div><div class="paragraph"><p>This is seriously unattractive code. We have doubled our line-count to <code>int-to-str</code> without adding too much functionality. For real world scenarios like batch processing a bunch of files, there are more ways that the program can go wrong. The middle code becomes messy very quickly.</p></div></section><section class="section" id="raise-dont-throw"><h3 class="section">3.3  &nbsp;&nbsp; Raise, don't Throw</h3><div class="paragraph"><p>This problem actually has a very elegant solution. Instead of throwing an exception, we can <code>raise</code> an issue in <code>check-unlucky</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn check-unlucky [n]
  (if (#{4 13 14 24 666} n)
    (raise [:unlucky-number {:value n}])
    n))</div></div><div class="paragraph"><p><code>int-to-str</code> does not have to change</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn int-to-str [n]
  (do (Thread/sleep 10)  ;; Work out something
      (str (check-unlucky n))))</div></div><div class="paragraph"><p>We still get the same functionality:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(int-to-str 1) =&gt; &quot;1&quot;

(mapv int-to-str (range 4))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot;]</div></div></section><section class="section" id="issues-and-abnormal-flow"><h3 class="section">3.4  &nbsp;&nbsp; Issues and Abnormal Flow</h3><div class="paragraph"><p>What happens when we use this with unlucky numbers? Its almost the same... except that instead of raising a <code>RuntimeException</code>, we get a <code>clojure.lang.ExceptionInfo</code> object:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(mapv int-to-str (range 20))
=&gt; (throws clojure.lang.ExceptionInfo)</div></div><div class="paragraph"><p>We can still use <code>try/catch</code> to recover from the error</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(try
  (mapv int-to-str (range 20))
  (catch clojure.lang.ExceptionInfo e
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</div></div><div class="paragraph"><p>We set up the handlers by replacing <code>try</code> with <code>manage</code> and <code>catch</code> with <code>on</code>. This gives the exact same result as before.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
  (mapv int-to-str (range 20))
  (on :unlucky-number []
    &quot;Unlucky number in the sequence&quot;))
=&gt; &quot;Unlucky number in the sequence&quot;</div></div></section><section class="section" id="a-sleight-of-hand"><h3 class="section">3.5  &nbsp;&nbsp; A Sleight of Hand</h3><div class="paragraph"><p>However, the whole point of this example is that we wish to keep the previous results without ever changing <code>int-to-str</code>. We will do this with <code>continue</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
  (mapv int-to-str (range 20))
  (on :unlucky-number []
      (continue &quot;-&quot;)))
=&gt; [&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;-&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot;
    &quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;-&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot;]</div></div><div class="paragraph"><p>So what just happened?</p><p><code>continue</code> is a special form that allows higher level functions to jump back into the place where the exception was called. So once the manage block was notified of the issue raised in <code>check-unlucky</code>, it did not blow away the stack but jumped back to the back at which the issue was raised and continued on with <code>-</code> instead. In this way, the exception handling code instead of being written in <code>int-to-str</code>, can now be written at the level that it is required.</p></div></section><section class="section" id="chinese-unlucky-numbers"><h3 class="section">3.6  &nbsp;&nbsp; Chinese Unlucky Numbers</h3><div class="paragraph"><p>The chinese don't like the number 4 and any number with the number 4, but they don't mind 13 and 666. We can write use the <code>on</code> handler to define cases to process:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn ints-to-strs-chinese [arr]
  (manage
   (mapv int-to-str arr)
   (on {:unlucky-number true
        :value #(or (= % 666)
                    (= % 13))}
       [value]
       (continue value))

   (on :unlucky-number []
       (continue &quot;-&quot;))))

(ints-to-strs-chinese [11 12 13 14])
=&gt; [&quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;-&quot;]

(ints-to-strs-chinese [1 2 666])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;666&quot;]</div></div></section><section class="section" id="christian-unlucky-numbers"><h3 class="section">3.7  &nbsp;&nbsp; Christian Unlucky Numbers</h3><div class="paragraph"><p>The christians don't mind numbers with 4, don't like 13 and really don't like 666. In this example, it can be seen that if 666 is seen, it will jump out and return straight away, but will continue on processing with other numbers.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn ints-to-strs-christian [arr]
  (manage
   (mapv int-to-str arr)
   (on [:unlucky-number] [value]
       (condp = value
         13 (continue &quot;-&quot;)
         666 &quot;ARRRGHHH!&quot;
         (continue value)))))

(ints-to-strs-christian [11 12 13 14])
=&gt; [&quot;11&quot; &quot;12&quot; &quot;-&quot; &quot;14&quot;]

(ints-to-strs-christian [1 2 666])
=&gt; &quot;ARRRGHHH!&quot;</div></div><div class="paragraph"><p>It can be seen from this example that the <code>int-to-str</code> function can be reused without any changes. this would be extremely difficult to do with just <code>try/catch</code>.</p><p>For the still sceptical, I'm proposing a <strong>challenge</strong>: to reimplement <code>ints-to-strs-christian</code> without changing <code>unlucky-numbers</code> or <code>int-to-str</code> using only <code>try</code> and <code>catch</code>.</p></div></section></section><section class="chapter" id="api"><h2 class="chapter">4  &nbsp;&nbsp; API</h2><section class="section" id="api-raise"><h3 class="section">4.1  &nbsp;&nbsp; raise</h3><div class="paragraph"><p>The keyword <code>raise</code> is used to raise an 'issue'. At the simplest, when there is no <code>manage</code> blocks, <code>raise</code> just throws a <code>clojure.lang.ExceptionInfo</code> object</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:title &quot;raise is of type clojure.lang.ExceptionInfo&quot; :tag &quot;raise-type&quot;}]]
(raise {:error true})
=&gt; (throws clojure.lang.ExceptionInfo)</div></div><div class="paragraph"><p>The payload of the issue can be extracted using <code>ex-data</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(try
  (raise {:error true})
  (catch clojure.lang.ExceptionInfo e
    (ex-data e)))
=&gt; {:error true}</div></div><div class="paragraph"><p>The payload can be expressed as a <code>hash-map</code>, a <code>keyword</code> or a <code>vector</code>. We define the <code>raises-issue</code> macro to help explore this a little further:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro raises-issue [payload]
  `(throws (fn [e#]
             ((just ~payload) (ex-data e#)))))</div></div><div class="paragraph"><p>Please note that the <code>raises-issue</code> macro is only working with <code>midje</code>. In order to work outside of midje, we need to define the <code>payload</code> macro:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro payload [&amp; body]
    `(try ~@body
          (throw (Throwable.))
          (catch clojure.lang.ExceptionInfo e#
            (ex-data e#))
          (catch Throwable t#
            (throw (Exception. &quot;No Issue raised&quot;)))))</div></div><div class="paragraph"><p>Its can be used to detect what type of issue has been raised:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(payload (raise :error))
=&gt; {:error true}</div></div><section class="subsection" id="hash-map"><h4 class="subsection">4.1.1  &nbsp;&nbsp; hash-map</h4><div class="paragraph"><p>Because the issue can be expressed as a hash-map, it is more general than using a class to represent exceptions.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(raise {:error true :data &quot;data&quot;})
=&gt; (raises-issue {:error true :data &quot;data&quot;})</div></div></section><section class="subsection" id="keyword"><h4 class="subsection">4.1.2  &nbsp;&nbsp; keyword</h4><div class="paragraph"><p>When a <code>keyword</code> is used, it is shorthand for a map with having the specified keyword with value <code>true</code>.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(raise :error)
=&gt; (raises-issue {:error true})</div></div></section><section class="subsection" id="vector"><h4 class="subsection">4.1.3  &nbsp;&nbsp; vector</h4><div class="paragraph"><p>Vectors can contain only keywords or both maps and keywords. They are there mainly for syntacic sugar</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(raise [:lvl-1 :lvl-2 :lvl-3])
=&gt; (raises-issue {:lvl-1 true :lvl-2 true :lvl-3 true})


(raise [:lvl-1 {:lvl-2 true :data &quot;data&quot;}])
 =&gt; (raises-issue {:lvl-1 true :lvl-2 true :data &quot;data&quot;})</div></div></section></section><section class="section" id="option--default"><h3 class="section">4.2  &nbsp;&nbsp; option/default</h3><div class="paragraph"><p>Strategies for an unmanaged issue can be specified within the raise form:<ul><li><a href='#option-one'>e.4.1</a> specifies two options and the specifies the default option as <code>:use-nil</code>.</li><li><a href='#option-two'>e.4.2</a> sets the default as <code>:use-custom</code> with an argument of <code>10</code>.</li><li><a href='#option-none'>e.4.3</a> shows that if there is no default selection, then an exception will be thrown as per previously seen:</li></ul></div><div class="code"><a name="option-one"></a><h5>e.4.1  &nbsp;-&nbsp; default :use-nil</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-nil))
=&gt; nil</div></div><div class="code"><a name="option-two"></a><h5>e.4.2  &nbsp;-&nbsp; default :use-custom</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-custom 10))
=&gt; 10</div></div><div class="code"><a name="option-none"></a><h5>e.4.3  &nbsp;-&nbsp; no default</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(raise :error
       (option :use-nil [] nil)
       (option :use-custom [n] n))
=&gt; (raises-issue {:error true})</div></div></section><section class="section" id="manage--on"><h3 class="section">4.3  &nbsp;&nbsp; manage/on</h3><div class="paragraph"><p>Raised issues can be resolved through use of <code>manage</code> blocks set up. The blocks set up execution scope, providing handlers and options to redirect program flow. A manage block looks like this:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage

 ... code that may raise issue ...

 (on &lt;chk&gt; &lt;bindings&gt;
     ... handler body ...)

 (option &lt;label&gt; &lt;bindings&gt;
     ... option body ...)

 (finally                   ;; only one
     ... finally body ...))</div></div><div class="paragraph"><p>We define <code>half-int</code> and its usage:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-int [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}])))</div></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(half-int 2)
=&gt; 1

(half-int 3)
=&gt; (raises-issue {:odd-number true :value 3})</div></div></section><section class="section" id="checkers"><h3 class="section">4.4  &nbsp;&nbsp; checkers</h3><div class="paragraph"><p>Within the <code>manage</code> form, issue handlers are specified with <code>on</code>. The form requires a check, which if returns true will be activated:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p>The checker can be a map with the value</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on {:odd-number true} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p>Or it can be a map with a checking function:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on {:odd-number true?} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p>A set will check if any elements are true</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on #{:odd-number} []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p>A vector will check if all elements are true </p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on [:odd-number] []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p>An underscore will match anything</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on _ []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div><div class="paragraph"><p><code>on-any</code> can also be used instead of <code>on &#95;</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on-any []
     &quot;odd-number-exception&quot;))
=&gt; &quot;odd-number-exception&quot;</div></div></section><section class="section" id="bindings"><h3 class="section">4.5  &nbsp;&nbsp; bindings</h3><div class="paragraph"><p>Bindings within the <code>on</code> handler allow values in the issue payload to be accessed:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number e
     (str &quot;odd-number: &quot; (:odd-number e) &quot;, value: &quot; (:value e))))
=&gt; &quot;odd-number: true, value: 1&quot;</div></div><div class="paragraph"><p>Bindings can be a vector</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [odd-number value]
     (str &quot;odd-number: &quot; odd-number &quot;, value: &quot; value)))
=&gt; &quot;odd-number: true, value: 1&quot;</div></div><div class="paragraph"><p>Bindings can also be a hashmap</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number {odd? :odd-number v :value}
     (str &quot;odd-number: &quot; odd? &quot;, value: &quot; v)))
=&gt; &quot;odd-number: true, value: 1&quot;</div></div></section><section class="section" id="catch-and-finally"><h3 class="section">4.6  &nbsp;&nbsp; catch and finally</h3><div class="paragraph"><p>The special forms <code>catch</code> and <code>finally</code> are also supported in the <code>manage</code> blocks for exception handling just as they are in <code>try</code> blocks.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (throw (Exception. &quot;Hello&quot;))
 (catch Exception e
   &quot;odd-number-exception&quot;)
 (finally
   (println &quot;Hello&quot;)))
=&gt; &quot;odd-number-exception&quot; ;; Also prints &quot;Hello&quot;</div></div><div class="paragraph"><p>They can be mixed and matched with <code>on</code> forms</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     &quot;odd-number-exception&quot;)
 (finally
   (println &quot;Hello&quot;)))
=&gt; &quot;odd-number-exception&quot; ;; Also prints &quot;Hello&quot;</div></div></section><section class="section" id="special-forms"><h3 class="section">4.7  &nbsp;&nbsp; special forms</h3><div class="paragraph"><p>There are five special forms that can be used within the <code>on</code> handler:<ul><li><a href='#api-continue'>continue</a></li><li><a href='#api-fail'>fail</a></li><li><a href='#api-choose'>choose</a></li><li><a href='#api-default'>default</a></li><li><a href='#api-escalate'>escalate</a></li></ul></div></section><section class="section" id="api-continue"><h3 class="section">4.8  &nbsp;&nbsp; continue</h3><div class="paragraph"><p>The <code>continue</code> special form is used to continue the operation from the point that the <code>issue</code> was raised (<a href='#continue-using-nan'>e.</a>). It must be pointed out that this is impossible to do using the <code>try/catch</code> paradigm because the all the information from the stack will be lost.</p><p>  The <code>on</code> handler can take keys of the <code>payload</code> of the raised <code>issue</code> as parameters. In <a href='#continue-using-str'>e.</a>, a vector containing strings of the odd numbers are formed. Whereas in <a href='#continue-using-fractions'>e.</a>, the on handler puts in fractions instead.</p></div><div class="code"><h5>e.4.4  &nbsp;-&nbsp; continue using nan</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number []
     (continue :nan)))
=&gt; [:nan 1 :nan 2]</div></div><div class="code"><h5>e.4.5  &nbsp;-&nbsp; continue using str</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [value]
     (continue (str value))))
=&gt; [&quot;1&quot; 1 &quot;3&quot; 2]</div></div><div class="code"><h5>e.4.6  &nbsp;-&nbsp; continue using fractions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int [1 2 3 4])
 (on :odd-number [value]
     (continue (/ value 2))))
=&gt; [1/2 1 3/2 2]</div></div></section><section class="section" id="api-fail"><h3 class="section">4.9  &nbsp;&nbsp; fail</h3><div class="paragraph"><p>The <code>fail</code> special form will forcibly cause an exception to be thrown. It is used when there is no need to advise managers of situation. More data can be added to the failure (<a href='#fail-example'>e.</a>).</p></div><div class="code"><h5>e.4.7  &nbsp;-&nbsp; failure</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
  (mapv half-int [1 2 3 4])
  (on :odd-number []
    (fail [:unhandled :error])))
=&gt; (raises-issue {:value 1 :odd-number true :unhandled true :error true})</div></div></section><section class="section" id="api-choose"><h3 class="section">4.10  &nbsp;&nbsp; choose</h3><div class="paragraph"><p>The <code>choose</code> special form is used to jump to a <code>option</code>. A new function <code>half-int-b</code> (<a href='#half-int-b-definition'>e.</a>) is defined giving options to jump to within the <code>raise</code> form.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-int-b [n]
    (if (= 0 (mod n 2))
      (quot n 2)
      (raise [:odd-number {:value n}]
             (option :use-nil [] nil)
             (option :use-nan [] :nan)
             (option :use-custom [n] n))))</div></div><div class="paragraph"><p>Its usage can be seen in <a href='#choose-ex-1'>e.4.8</a> where different paths can be chosen depending upon <code>:value</code>. An option can also be specified in the manage block (<a href='#choose-ex-2'>e.4.9</a>). Options can also be overridden when specified in higher manage blocks (<a href='#choose-ex-3'>e.4.10</a>). </p></div><div class="code"><a name="choose-ex-1"></a><h5>e.4.8  &nbsp;-&nbsp; choosing different paths based on value</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int-b [1 2 3 4])
 (on {:value 1} []
     (choose :use-nil))
 (on {:value 3} [value]
     (choose :use-custom (/ value 2))))
=&gt; [nil 1 3/2 2]</div></div><div class="code"><a name="choose-ex-2"></a><h5>e.4.9  &nbsp;-&nbsp; choosing option within manage form</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int-b [1 2 3 4])
 (on :odd-number []
     (choose :use-empty))
 (option :use-empty [] []))
=&gt; []</div></div><div class="code"><a name="choose-ex-3"></a><h5>e.4.10  &nbsp;-&nbsp; overwriting :use-nil within manage form</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int-b [1 2 3 4])
 (on :odd-number []
     (choose :use-nil))
 (option :use-nil [] nil))
=&gt; nil</div></div></section><section class="section" id="api-default"><h3 class="section">4.11  &nbsp;&nbsp; default</h3><div class="paragraph"><p> The <code>default</code> special short-circuits the raise process and skips managers further up to use an issue's default option. A function is defined and is usage is shown how the <code>default</code> form behaves. </p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-int-c [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}]
           (option :use-nil [] nil)
           (option :use-custom [n] n)
           (default :use-custom :odd))))

(manage
 (mapv half-int-c [1 2 3 4])
 (on :odd-number [value] (default)))
=&gt; [:odd 1 :odd 2]</div></div><div class="paragraph"><p>The <code>default</code> form can even refer to an option that has to be implemented higher up in scope. An additional function is defined: </p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-int-d [n]
  (if (= 0 (mod n 2))
    (quot n 2)
    (raise [:odd-number {:value n}]
           (default :use-empty))))</div></div><div class="paragraph"><p>The usage for <code>half-int-d</code> can be seen in (<a href='#d-alone'>e.4.11</a> and <a href='#d-higher'>e.4.12</a>) to show these particular cases.</p></div><div class="code"><a name="d-alone"></a><h5>e.4.11  &nbsp;-&nbsp; half-int-d alone</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(half-int-d 3)
=&gt; (throws java.lang.Exception &quot;RAISE_CHOOSE: the label :use-empty has not been implemented&quot;)</div></div><div class="code"><a name="d-higher"></a><h5>e.4.12  &nbsp;-&nbsp; half-int-d inside manage block</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
 (mapv half-int-d [1 2 3 4])
 (option :use-empty [] [])
 (on :odd-number []
     (default)))
=&gt; []</div></div></section><section class="section" id="api-escalate"><h3 class="section">4.12  &nbsp;&nbsp; escalate</h3><div class="paragraph"><p>The <code>escalate</code> special form is used to add additional information to the issue and raised to higher managers. In the following example, if a <code>3</code> or a <code>5</code> is seen, then the flag <code>:three-or-five</code> is added to the issue and the <code>:odd-number</code> flag is set false.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-array-e [arr]
  (manage
    (mapv half-int-d arr)
    (on {:value (fn [v] (#{3 5} v))} [value]
        (escalate [:three-or-five {:odd-number false}]))))

(manage
  (half-array-e [1 2 3 4 5])
  (on :odd-number [value]
      (continue (* value 10)))
  (on :three-or-five [value]
      (continue (* value 100))))
  =&gt; [10 1 300 2 500]</div></div><div class="paragraph"><p>Program decision points can be changed by higher level managers through <code>escalate</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn half-int-f [n]
 (manage
   (if (= 0 (mod n 2))
     (quot n 2)
     (raise [:odd-number {:value n}]
       (option :use-nil [] nil)
       (option :use-custom [n] n)
       (default :use-nil)))

    (on :odd-number []
      (escalate :odd-number
        (option :use-zero [] 0)
        (default :use-custom :nan)))))

(half-int-f 3) =&gt; :nan  ;; (instead of nil)
(mapv half-int-f [1 2 3 4])

=&gt; [:nan 1 :nan 2] ;; notice that the default is overridden

(manage
  (mapv half-int-f [1 2 3 4])
  (on :odd-number []
    (choose :use-zero)))

=&gt; [0 1 0 2]   ;; using an escalated option</div></div><div class="paragraph"><p>Options specified higher up are favored:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(manage
  (mapv half-int-f [1 2 3 4])
  (on :odd-number []
    (choose :use-nil)))

  =&gt; [nil 1 nil 2]

  (manage
   (mapv half-int-f [1 2 3 4])
   (on :odd-number []
     (choose :use-nil))
   (option :use-nil [] nil))

  =&gt; nil  ;; notice that the :use-nil is overridden</div></div></section></section><section class="chapter" id="strategies"><h2 class="chapter">5  &nbsp;&nbsp; Strategies</h2><div class="group"><div class="paragraph"><p>This is a comprehensive (though non-exhaustive) list of program control strategies that can be used. It can be noted that the <code>try/catch</code> paradigm can implement sections <a href='#normal'>5.1</a> and <a href='#catch'>5.2</a>. Other clojure restart libraries such as <code>errorkit</code>, <code>swell</code> and <code>conditions</code> additionally implement sections <a href='#continue'>5.3</a>, <a href='#choose'>5.4</a> and <a href='#choose-more'>5.5</a>.</p><p><code>hara.event</code> supports novel (and more natural) program control mechanics through the <code>escalate</code> (<a href='#escalate'>5.6</a>), <code>fail</code> (<a href='#fail'>5.7</a>) and  <code>default</code> (<a href='#default'>5.8</a>) special forms as well as branching support in the <code>on</code> special form (<a href='#on-form'>5.9</a>).</p></div></div><section class="section" id="normal"><h3 class="section">5.1  &nbsp;&nbsp; Normal</h3><section class="subsection" id="no-raise"><h4 class="subsection">5.1.1  &nbsp;&nbsp; No Raise</h4><div class="paragraph"><p>The most straightforward code is one where no issues raised:</p></div><div class="code"><a name="event-normal-eq"></a><h5>e.5.1  &nbsp;-&nbsp; No Issues</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
  [1 2 (manage 3)])              ;; L1 and L0
=&gt; [1 2 3]</div></div><div class="figure"><a name="no-issues-flow"></a><div class="img"><img height="300px" src="img/hara_event/norm_normal.png" /></div><h4><i>fig.2  &nbsp;-&nbsp; No Issues Flow</i></h4></div></section><section class="subsection" id="issue-raised"><h4 class="subsection">5.1.2  &nbsp;&nbsp; Issue Raised</h4><div class="paragraph"><p>If there is an issue raised with no handler, it will <code>throw</code> an exception.</p></div><div class="code"><h5>e.5.2  &nbsp;-&nbsp; Unmanaged Issue</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise {:A true}))])      ;; L0
=&gt; (raises-issue {:A true})</div></div><div class="figure"><a name="unmanaged-issue-flow"></a><div class="img"><img height="300px" src="img/hara_event/norm_unmanaged.png" /></div><h4><i>fig.3  &nbsp;-&nbsp; Unmanaged Issue Flow</i></h4></div></section></section><section class="section" id="catch"><h3 class="section">5.2  &nbsp;&nbsp; Catch</h3><div class="paragraph"><p>Once an issue has been raised, it can be handled within a managed scope through the use of 'on'. 'manage/on' is the equivalent to 'try/catch' in the following two cases:</p></div><section class="subsection" id="first-level-catch"><h4 class="subsection">5.2.1  &nbsp;&nbsp; First Level Catch</h4><div class="code"><h5>e.5.3  &nbsp;-&nbsp; Catch on :A</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A)                ;; L0
       (on :A [] :A))]           ;; H1A
 (on :B [] :B))                  ;; H2B
=&gt; [1 2 :A]</div></div><div class="figure"><a name="catch-on-a-flow"></a><div class="img"><img height="300px" src="img/hara_event/catch_flow_a.png" /></div><h4><i>fig.4  &nbsp;-&nbsp; Catch on :A Flow</i></h4></div></section><section class="subsection" id="second-level-catch"><h4 class="subsection">5.2.2  &nbsp;&nbsp; Second Level Catch</h4><div class="code"><h5>e.5.4  &nbsp;-&nbsp; Catch on :B</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :B)                ;; L0
       (on :A [] :A))]           ;; H1A
 (on :B [] :B))                  ;; H2B
=&gt; :B</div></div><div class="figure"><a name="catch-on-b-flow"></a><div class="img"><img height="300px" src="img/hara_event/catch_flow_b.png" /></div><h4><i>fig.5  &nbsp;-&nbsp; Catch on :B Flow</i></h4></div></section></section><section class="section" id="continue"><h3 class="section">5.3  &nbsp;&nbsp; Continue</h3><div class="paragraph"><p>The 'continue' form signals that the program    should resume at the point that the issue    was raised.</p></div><section class="subsection" id="first-level-continue"><h4 class="subsection">5.3.1  &nbsp;&nbsp; First Level Continue</h4><div class="paragraph"><p>In the first case, this gives the same result as <code>try/catch</code>.</p></div><div class="code"><h5>e.5.5  &nbsp;-&nbsp; Continue on :A</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A)                ;; L0
       (on :A []                 ;; H1A
           (continue :3A)))]
 (on :B []                       ;; H2B
     (continue :3B)))
=&gt; [1 2 :3A]</div></div><div class="figure"><a name="continue-on-a-flow"></a><div class="img"><img height="300px" src="img/hara_event/continue_flow_a.png" /></div><h4><i>fig.6  &nbsp;-&nbsp; Continue on :A Flow</i></h4></div></section><section class="subsection" id="second-level-continue"><h4 class="subsection">5.3.2  &nbsp;&nbsp; Second Level Continue</h4><div class="paragraph"><p>However, it can be seen that when 'continue' is used    on the outer manage blocks, it provides the 'manage/on'    a way for top tier forms to affect the bottom tier forms    without manipulating logic in the middle tier</p></div><div class="code"><h5>e.5.6  &nbsp;-&nbsp; Continue on :B</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :B)                ;; L0
       (on :A []                 ;; H1A
           (continue :3A)))]
 (on :B []                       ;; H2B
     (continue :3B)))
=&gt; [1 2 :3B]</div></div><div class="figure"><a name="continue-on-b-flow"></a><div class="img"><img height="300px" src="img/hara_event/continue_flow_b.png" /></div><h4><i>fig.7  &nbsp;-&nbsp; Continue on :B Flow</i></h4></div></section></section><section class="section" id="choose"><h3 class="section">5.4  &nbsp;&nbsp; Choose</h3><div class="paragraph"><p><code>choose</code> and <code>option</code> work together within manage scopes. A raised issue can have options attached to it, just a worker might give their manager certain options to choose from when an unexpected issue arises. Options can be chosen that lie anywhere within the manage blocks.</p></div><section class="subsection" id="choose-lower-level"><h4 class="subsection">5.4.1  &nbsp;&nbsp; Choose Lower-Level</h4><div class="code"><h5>e.5.7  &nbsp;-&nbsp; Choose :X</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                           ;; L2
 [1 2 (manage                     ;; L1
        (raise :A                  ;; L0
               (option :X [] :3X)) ;; X
        (on :A []                  ;; H1A
            (choose :X))
        (option :Y [] :3Y))]       ;; Y
   (option :Z [] :3Z))              ;; Z
=&gt; [1 2 :3X]</div></div><div class="figure"><a name="choose-x-flow"></a><div class="img"><img height="300px" src="img/hara_event/choose_flow_x.png" /></div><h4><i>fig.8  &nbsp;-&nbsp; Choose :X Flow</i></h4></div><div class="paragraph"><p>However in some cases, upper level options can be accessed as in this case. This can be used to set global strategies to deal with very issues that have serious consequences if it was to go ahead.</p><p>   An example maybe a mine worker who finds a gas-leak. Because of previously conveyed instructions, he doesn't need to inform his manager and shuts down the plant immediately.</p></div></section><section class="subsection" id="choose-upper-level"><h4 class="subsection">5.4.2  &nbsp;&nbsp; Choose Upper-Level</h4><div class="code"><h5>e.5.8  &nbsp;-&nbsp; Choose :Z</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                           ;; L2
 [1 2 (manage                     ;; L1
       (raise :A                  ;; L0
              (option :X [] :3X)) ;; X
       (on :A []                  ;; H1A
           (choose :Z))
       (option :Y [] :3Y))]       ;; Y
 (option :Z [] :3Z))              ;; Z
=&gt; :3Z</div></div><div class="figure"><a name="choose-z-flow"></a><div class="img"><img height="300px" src="img/hara_event/choose_flow_z.png" /></div><h4><i>fig.9  &nbsp;-&nbsp; Choose :Z Flow</i></h4></div></section></section><section class="section" id="choose-more"><h3 class="section">5.5  &nbsp;&nbsp; Choose - More Strategies</h3><section class="subsection" id="overridding-an-option"><h4 class="subsection">5.5.1  &nbsp;&nbsp; Overridding An Option</h4><div class="paragraph"><p>If there are two options with the same label,   choose will take the option specified at the highest   management level. This means that managers at higher   levels can over-ride lower level strategies.</p></div><div class="code"><h5>e.5.9  &nbsp;-&nbsp; Choose :X1</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (option :X [] :3X0)) ;; X0 - This is ignored
       (on :A []                   ;; H1A
         (choose :X))
       (option :X [] :3X1))]       ;; X1 - This is chosen
 (option :Z [] :3Z))               ;; Z
=&gt; [1 2 :3X1]</div></div><div class="figure"><a name="choose-x1-flow"></a><div class="img"><img height="300px" src="img/hara_event/choose_flow_x1.png" /></div><h4><i>fig.10  &nbsp;-&nbsp; Choose :X1 Flow</i></h4></div></section><section class="subsection" id="default-option"><h4 class="subsection">5.5.2  &nbsp;&nbsp; Default Option</h4><div class="paragraph"><p>Specifying a 'default' option allows the raiser to    have autonomous control of the situation if the issue    remains unhandled.</p></div><div class="code"><h5>e.5.10  &nbsp;-&nbsp; Choose Default</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (default :X)         ;; D
              (option :X [] :3X))  ;; X
       (option :Y [] :3Y))]        ;; Y
 (option :Z [] :3Z))               ;; Z
=&gt; [1 2 :3X]</div></div><div class="figure"><a name="choose-default-flow"></a><div class="img"><img height="300px" src="img/hara_event/choose_default_x.png" /></div><h4><i>fig.11  &nbsp;-&nbsp; Choose Default Flow</i></h4></div></section><section class="subsection" id="overriding-defaults"><h4 class="subsection">5.5.3  &nbsp;&nbsp; Overriding Defaults</h4><div class="paragraph"><p>This is an example of higher-tier managers overriding options</p></div><div class="code"><h5>e.5.11  &nbsp;-&nbsp; Choose Default :X2</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
              (default :X)         ;; D
              (option :X [] :3X0)) ;; X0
       (option :X [] :3X1))]       ;; X1
  (option :X [] :3X2))             ;; X2
=&gt; :3X2</div></div><div class="figure"><a name="choose-default-x2-flow"></a><div class="img"><img height="300px" src="img/hara_event/choose_default_x2.png" /></div><h4><i>fig.12  &nbsp;-&nbsp; Choose Default :X2 Flow</i></h4></div></section></section><section class="section" id="escalate"><h3 class="section">5.6  &nbsp;&nbsp; Escalate</h3><section class="subsection" id="simple-escalation"><h4 class="subsection">5.6.1  &nbsp;&nbsp; Simple Escalation</h4><div class="paragraph"><p>When issues are escalated, more information  can be added and this then is passed on to higher-tier managers</p></div><div class="code"><h5>e.5.12  &nbsp;-&nbsp; Escalate :B</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A)                  ;; L0
       (on :A []                   ;; H1A
          (escalate :B)))]
 (on :B []                         ;; H2B
     (continue :3B)))
=&gt; [1 2 :3B]</div></div><div class="figure"><a name="escalate-b-flow"></a><div class="img"><img height="300px" src="img/hara_event/escalate_norm.png" /></div><h4><i>fig.13  &nbsp;-&nbsp; Escalate :B Flow</i></h4></div></section><section class="subsection" id="escalation-with-options"><h4 class="subsection">5.6.2  &nbsp;&nbsp; Escalation with Options</h4><div class="paragraph"><p>More options can be added to escalate. When these options are chosen, it will continue at the point in which the issue was raised.</p></div><div class="code"><h5>e.5.13  &nbsp;-&nbsp; Escalate :B, Choose :X</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A)                  ;; L0
       (on :A []                   ;; H1A
           (escalate
            :B
            (option :X [] :3X))))] ;; X
  (on :B []                        ;; H2B
      (choose :X)))
=&gt; [1 2 :3X]</div></div><div class="figure"><a name="escalate-b-choose-x-flow"></a><div class="img"><img height="300px" src="img/hara_event/escalate_options.png" /></div><h4><i>fig.14  &nbsp;-&nbsp; Escalate :B, Choose :X Flow</i></h4></div></section></section><section class="section" id="fail"><h3 class="section">5.7  &nbsp;&nbsp; Fail</h3><div class="paragraph"><p>Fail forces a failure. It is used where there is already a default    option and the manager really needs it to fail.</p></div><div class="code"><h5>e.5.14  &nbsp;-&nbsp; Force Failure</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A                 ;; L0
              (option :X [] :X)
              (default :X))
       (on :A []                 ;; H1A
           (fail :B)))])
=&gt; (raises-issue {:A true :B true})</div></div><div class="figure"><a name="force-fail-flow"></a><div class="img"><img height="300px" src="img/hara_event/fail.png" /></div><h4><i>fig.15  &nbsp;-&nbsp; Force Fail Flow</i></h4></div></section><section class="section" id="default"><h3 class="section">5.8  &nbsp;&nbsp; Default</h3><div class="paragraph"><p>Default short-circuits higher managers so that    the issue is resolved internally.</p></div><div class="code"><h5>e.5.15  &nbsp;-&nbsp; Force Default</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                          ;; L2
 [1 2 (manage                    ;; L1
       (raise :A                 ;; L0
              (option :X [] :X)
              (default :X))
       (on :A []                  ;; H1A
           (default)))]
 (on :A [] (continue 3)))
=&gt; [1 2 :X]</div></div><section class="subsection" id="escalation-with-defaults"><h4 class="subsection">5.8.1  &nbsp;&nbsp; Escalation with Defaults</h4><div class="paragraph"><p>This is <code>default</code> in combination with <code>escalate</code> to do some very complex jumping around.</p></div><div class="code"><h5>e.5.16  &nbsp;-&nbsp; Escalate :B, Choose Default</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage                            ;; L2
 [1 2 (manage                      ;; L1
       (raise :A                   ;; L0
         (option :X [] :X))        ;; X
       (on :A []                   ;; H1A
           (escalate
            :B
            (default :X))))]       ;; D1
  (on :B []                        ;; H2B
      (default)))
=&gt; [1 2 :X]</div></div><div class="figure"><a name="escalate-b-choose-default-flow"></a><div class="img"><img height="300px" src="img/hara_event/escalate_default_x2.png" /></div><h4><i>fig.16  &nbsp;-&nbsp; Escalate :B, Choose Default Flow</i></h4></div></section></section><section class="section" id="on-form"><h3 class="section">5.9  &nbsp;&nbsp; Branch Using On</h3><div class="paragraph"><p>Customized strategies can also be combined within the <code>on</code> handler. In the following example, it can be seen that the <code>on :error</code> handler supports both <code>escalate</code> and <code>continue</code> strategies.</p></div><div class="code"><h5>e.5.17  &nbsp;-&nbsp; Input Dependent Branching</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(manage (manage
         (mapv (fn [n]
                 (raise [:error {:data n}]))
               [1 2 3 4 5 6 7 8])
         (on :error [data]
             (if (&gt; data 5)
               (escalate :too-big)
               (continue data))))
        (on :too-big [data]
            (continue (- data))))
=&gt; [1 2 3 4 5 -6 -7 -8]</div></div><div class="paragraph"><p>Using branching strategies with <code>on</code> much more complex interactions can be constructed beyond the scope of this document.</p></div></section></section><section class="chapter" id="implementation"><h2 class="chapter">6  &nbsp;&nbsp; Implementation</h2><div class="group"><div class="paragraph"><p>Two macros - <code>raise</code> and <code>manage</code> work together in creating the illusion of allowing code to seemingly jump around between higher and lower level functions. This in reality is not the case at all. We revisit the analogy of the worker who comes across something in their everyday routine that they cannot process.</p></div></div><section class="section" id="the-dumb-throw"><h3 class="section">6.1  &nbsp;&nbsp; The dumb throw</h3><div class="paragraph"><p>When <code>&#40;throw .....&#41;</code> is invoked, the worker basically says: <em>'Dude, I quit! You deal with it'</em> and lets higher up managers deal with the consequences.</p></div><div class="figure"><a name="lazy-worker"></a><div class="img"><img height="300px" src="img/hara_event/work_throw.png" /></div><h4><i>fig.17  &nbsp;-&nbsp; Lazy Worker</i></h4></div></section><section class="section" id="the-smart-raise"><h3 class="section">6.2  &nbsp;&nbsp; The smart raise</h3><div class="paragraph"><p>When <code>&#40;raise ....&#41;</code> is used, the worker will attempt to notify their manager and ask for instructions. Only when there are no instructions forthcoming will they quit:</p></div><div class="code"><h5>e.6.1  &nbsp;-&nbsp; Continue Example</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn dislike-odd [n]
  (if (odd? n) (raise :error) n))

(manage
 (mapv dislike-odd (range 10))
 (on :error [] (continue :odd)))
=&gt; [0 :odd 2 :odd 4 :odd 6 :odd 8 :odd]</div></div><div class="paragraph"><p>Purely from looking at the example code, it reads:</p><ul><li>perform <code>mapv</code> of <code>dislike-odd</code> over the range of 0 to 10</li><li>if <code>:error</code> is raised by <code>dislike-odd</code>, tell <code>dislike-odd</code> to proceed at the point that the error was raised, using the value <code>:odd</code> instead.</li></ul></div><div class="figure"><a name="smart-worker"></a><div class="img"><img height="300px" src="img/hara_event/work_raise.png" /></div><h4><i>fig.18  &nbsp;-&nbsp; Smart Worker</i></h4></div><div class="paragraph"><p>Anytime there is an odd input to <code>dislike-odd</code>, the code seemingly jumps out to the context of the manager and having handled the issue, the code then seemingly jumps back into the function again.</p><p>Note the words <code>seemingly</code>. This is how we as programmers should be thinking about the problem as we write code to handle these type of issues. We are tricked for our own good because it makes us able to better reason about our programs without having to deal with the implementation details.</p><p>However, we are naturally suspicious of this from a performance point of view. If we don't know the mechanism, we ask ourselves... won`t all this jumping around make our code slower?</p></div></section><section class="section" id="being-proactive"><h3 class="section">6.3  &nbsp;&nbsp; Being Proactive</h3><div class="paragraph"><p>In reality, the program never left the place where <code>raise</code> was called. There was no saving of the stack or anything fancy. The <code>raise/continue</code> combination was an <em>illusion</em> of a jump. There was no jump. Calling <code>raise/continue</code> is most likely computationally cheaper than <code>try/catch</code>.</p><p>Going back to the workplace analogy, another way to manage exceptional circumstances is to have a prearranged noticeboard of what to do when things go wrong. Managers can write/override different ways to handle an issue on this board proactively. The worker, when encountering an issue, would go look at the board first to decide upon the best course of action to take. Only when there are no matching solutions to the issue will they solve it themselves or give up and quit. In this way, managers will not have to be called everytime something came up. This is the same mechanism of control that <code>hara.event</code> uses.</p></div><div class="figure"><a name="proactive-management"></a><div class="img"><img height="300px" src="img/hara_event/work_board.png" /></div><h4><i>fig.19  &nbsp;-&nbsp; Proactive Management</i></h4></div></section><section class="section" id="the-issue-management-board"><h3 class="section">6.4  &nbsp;&nbsp; The Issue Management Board</h3><div class="paragraph"><p>We look at what happens when there is such an Issue Management Board put in place. <code>raise</code> is called. The worker will look at the board, starting with lowest level manager and proceeding up the management chain to see what strategies has to be been put into place. In the case of <a href='#continue-example'>e.</a>, there would have been a handler already registered on the board to deal with the <code>:error</code>. The worker will pass any arguments of the issue to the handler function and then return with the result.</p></div><div class="figure"><a name="img-img--hara-event--notice-board-png"></a><div class="img"><img height="300px" src="img/hara_event/notice_board.png" /></div></div><div class="paragraph"><p>The management does not even need to know that an exception has occured because they have been proactive.</p></div></section><section class="section" id="control-flow-as-data"><h3 class="section">6.5  &nbsp;&nbsp; Control Flow as Data</h3><div class="paragraph"><p>Whilst the <code>raise/continue</code> mechanism was decribed in brief, a bit more explanation is required to understand how different forms of jumps occur. The 5 special forms are implemented as data-structures:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro continue [&amp; body]
  `{::type :continue ::value (do ~@body)})

(defmacro default [&amp; args]
  `{::type :default ::args (list ~@args)})

(defmacro choose [label &amp; args]
  `{::type :choose ::label ~label ::args (list ~@args)})

(defmacro fail
  ([] {::type :fail})
  ([contents]
     `{::type :fail ::contents ~contents}))</div></div><div class="paragraph"><p><code>escalate</code> is not shown because it a bit more complex as options and defaults can. Essentially, it is still just a data structure.</p><p>The <code>raise</code> macro calls <code>raise-loop</code> which looks at the <code>::type</code> signature of the result returned by the <code>on</code> handler.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn raise-loop [issue managers optmap]
  (... code ...
       (condp = (::type res)
         :continue (::value res)
         :choose (raise-choose issue (::label res) (::args res) optmap)
         :default (raise-unhandled issue optmap)
         :fail (raise-fail issue (::contents res))
         :escalate (raise-escalate issue res managers optmap)
         (raise-catch mgr res)))

  ... code ...)</div></div><div class="paragraph"><p>In the case of <code>:continue</code>, it can be seen that the function just returns <code>&#40;::value res&#41;</code>. The function in which <code>raise</code> was called proceeds without ever jumping anywhere.</p><p>In the case of other forms, there are different handlers to handle each case. If the <code>on</code> handler returns a non-special form value, it will call <code>raise-catch</code>. So it is possible to mess with the internals of <code>hara.event</code> by creating a datastructure of the same format of the special forms.</p></div></section><section class="section" id="implementing-catch"><h3 class="section">6.6  &nbsp;&nbsp; Implementing Catch</h3><div class="paragraph"><p>To understand how <code>catch</code> is implemented, we have to look at the <code>manage</code> macro:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro manage
  ... code ...

  `(binding [*managers* (cons ~manager *managers*)
             *optmap* (merge ~optmap *optmap*)]
     (try
       ~@body-forms
       (catch clojure.lang.ExceptionInfo ~'ex
         (manage-signal ~manager ~'ex))
       ~@finally-forms)))</div></div><div class="paragraph"><p>So essentially, it is a <code>try/catch</code> block wrapped in an <code>binding</code> form.</p></div><div class="paragraph"><p>When <code>raise-loop</code> gets a non-special form value back from a function handler in the manager it will call <code>raise-catch</code>, which will create a <code>catch</code> signal and actually throw it. The signal is just a clojure.lang.ExceptionInfo. The signal has a <code>::target</code>, which is the <code>:id</code> of the manager. It also has <code>::value</code>, which is the original result from <code>on</code>.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn- raise-catch [manager value]
  (throw (create-catch-signal (:id manager) value)))

(defn- create-catch-signal
  [target value]
  (ex-info &quot;catch&quot; {::signal :catch ::target target ::value value}))</div></div><div class="paragraph"><p>Going back to the <code>manage</code> block, it can be seen that <code>manage</code> will catch any <code>clojure.lang.ExceptionInfo</code> objects thrown. When a signal is thrown from lower functions, it will be caught and <code>manage-signal</code> is then called. If the target does not match the :id, then the exception is rethrown. If the exception has <code>::signal</code> of <code>:catch</code> then the manager will return <code>&#40;::value data&#41;</code>.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn manage-signal [manager ex]
  (let [data (ex-data ex)]
    (cond (not= (:id manager) (::target data))
          (throw ex)

          ... choose code ....

          (= :catch (::signal data))
          (::value data)

          :else (throw ex))))</div></div></section><section class="section" id="implementing-choose"><h3 class="section">6.7  &nbsp;&nbsp; Implementing Choose</h3><div class="paragraph"><p>Choose works with options. It can be seen that apart from the <code>&#42;managers&#42;</code> structure, there is also an <code>&#42;optmap&#42;</code>. The optmap holds as the key/value pairs the labels of what options are registered and the id of the manager that provided the option.</p><p>Choose also requires that a signal be sent, but the target will now be a lookup on the optmap given an option label. The signal is very similar to the <code>catch</code> signal.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn- create-choose-signal
  [target label args]
   (ex-info &quot;choose&quot; {::signal :choose ::target target ::label label ::args args}))</div></div><div class="paragraph"><p>The part that processes <code>:choose</code> is shown in <code>manage-signal</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defn manage-signal
   ...
     (= :choose (::signal data))
     (let [label (::label data)
           f (get (:options manager) label)
           args (::args data)]
       (manage-apply f args label))
  ...)</div></div></section><section class="section" id="implementing-the-rest"><h3 class="section">6.8  &nbsp;&nbsp; Implementing the Rest</h3><div class="paragraph"><p><code>fail</code>, <code>default</code>, <code>escalate</code> all use similar <em>data as control-flow</em> mechanisms to allow control to be directed to the correct part of the program. It is through this mechanism that branching in the <code>on</code> handlers can be achieved.</p></div></section></section><section class="chapter" id="links-and-resources"><h2 class="chapter">7  &nbsp;&nbsp; Links and Resources</h2><div class="group"><div class="paragraph"><p>Here are some more links and resources on the web:</p><ul><li><a href='http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html'>beyond exception handling</a> - Peter Seibel's chapter on conditional restarts</li><li><a href='http://z.caudate.me/why-exceptions-are-like-stylesheets/'>why exceptions should cascade like stylesheets</a> - original article on the philosophy behind <a href='http://www.github.com/zcaudate/ribol'>ribol</a></li><li><a href='http://www.youtube.com/watch?v=GDVAHA0oyJU'>the power of abstraction</a> - excellent talk by Barbara Liskov</li></ul></div></div></section>
    </div>
</div><!--end of .container-->

  <section class="application">
    
  </section>
</body>

<script>
  $('#nav').affix({
    offset: {
        top: $('#nav').offset().top,
        bottom: $('footer').outerHeight(true) + $('.application').outerHeight(true) + 40
    }});
</script>


<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</body>
</html>
