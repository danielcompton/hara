

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <meta name="google" value="notranslate">


    <title>concurrent.procedure</title>

    
  <link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/clojure.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/magula.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.2/angular.min.js"></script>
  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular-cookies.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.13.0/ui-bootstrap-tpls.min.js"></script>
  <script type="text/javascript" src="js/angular-highlightjs.min.js"></script>

  <link rel="stylesheet" type="text/css" href="css/rdash.min.css">
  <link rel="stylesheet" type="text/css" href="css/scrollspy.css">


  <script>
    window.console = window.console || function(t) {};
    window.open = function(){ console.log("window.open is disabled."); };
    window.print   = function(){ console.log("window.print is disabled."); };
  </script>

  <script>
    var app = angular.module('app', ['hljs']);
  </script>
  </head>

  <body ng-app="app" data-spy="scroll" data-target=".scrollspy">
  <!-- Fixed navbar -->
    <nav class="navbar navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html"><img src="img/logo.png"></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Guides <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="hara-class.html">class</a></li>
                <li><a href="hara-common.html">common</a></li>
                <li><a href="hara-component.html">component</a></li>
                <li><a href="hara-concurrent.html">concurrent</a></li>
                <li><a href="hara-concurrent-ova.html">concurrent.ova</a></li>
                <li><a href="hara-concurrent-procedure.html">concurrent.procedure</a></li>
                <li><a href="hara-data.html">data</a></li>
                <li><a href="hara-event.html">event</a></li>
                <li><a href="hara-expression.html">expression</a></li>
                <li><a href="hara-extend.html">extend</a></li>
                <li><a href="hara-function.html">function</a></li>
                <li><a href="hara-group.html">group</a></li>
                <li><a href="hara-io-environment.html">io.environment</a></li>
                <li><a href="hara-io-scheduler.html">io.scheduler</a></li>
                <li><a href="hara-io-watch.html">io.watch</a></li>
                <li><a href="hara-namespace.html">namespace</a></li>
                <li><a href="hara-object.html">object</a></li>
                <li><a href="hara-reflect.html">reflect</a></li>
                <li><a href="hara-sort.html">sort</a></li>
                <li><a href="hara-string.html">string</a></li>
                <li><a href="hara-time.html">time</a></li>
            </ul>
            </li>
            <li>
              <a href="https://github.com/zcaudate/hara" target="_blank">Github</a></li>
            <li>
              <a href="http://gitter.im/zcaudate/hara" target="_blank">Gitter</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


  <div class="container row">
    <div class="col-md-4 scrollspy pull-right">
      <ul id="nav" class="nav hidden-xs hidden-sm" data-spy="affix">
        <li><a href="#introduction">1  &nbsp;&nbsp; Introduction</a><ul class="nav"><li><a href="#installation">1.1  &nbsp;&nbsp; Installation</a></li><li><a href="#motivation">1.2  &nbsp;&nbsp; Motivation</a></li></ul></li><li><a href="#features">2  &nbsp;&nbsp; Features</a><ul class="nav"><li><a href="#basics">2.1  &nbsp;&nbsp; Basics</a></li><li><a href="#mode">2.2  &nbsp;&nbsp; Mode</a></li><li><a href="#control-of-execution">2.3  &nbsp;&nbsp; Control of Execution</a></li><li><a href="#instance">2.4  &nbsp;&nbsp; Instance</a></li><li><a href="#runtime-and-registry">2.5  &nbsp;&nbsp; Runtime and Registry</a></li><li><a href="#identity-and-caching">2.6  &nbsp;&nbsp; Identity and Caching</a></li><li><a href="#intermission">2.7  &nbsp;&nbsp; Intermission</a></li><li><a href="#overwrite">2.8  &nbsp;&nbsp; Overwrite</a></li><li><a href="#interrupt">2.9  &nbsp;&nbsp; Interrupt</a></li><li><a href="#time">2.10  &nbsp;&nbsp; Time</a></li></ul></li><li><a href="#retries">3  &nbsp;&nbsp; Retries</a><ul class="nav"><li><a href="#simple">3.1  &nbsp;&nbsp; Simple</a></li><li><a href="#wait">3.2  &nbsp;&nbsp; Wait</a></li><li><a href="#arguments">3.3  &nbsp;&nbsp; Arguments</a></li><li><a href="#handlers">3.4  &nbsp;&nbsp; Handlers</a></li></ul></li>
      </ul>
    </div>
    <div class="col-md-8" id="content">
      <div class="jumbotron">
        <div class="container">
          <h1>concurrent.procedure</h1>
          <h4>model for controllable execution</h4>
        </div>
      </div>
      <section class="chapter" id="introduction"><h2 class="chapter">1  &nbsp;&nbsp; Introduction</h2><div class="group"><div class="paragraph"><p><code>hara.concurrent.procedure</code> provides a wrapper-like layer for controlling the execution of concurrent operations. Many features are added in order to support use in the real world. These include restarts, interrupts, timeouts, caching, synchronous/asynchronous dispatch, timing and other issues associated with concurrent systems.</p></div></div><section class="section" id="installation"><h3 class="section">1.1  &nbsp;&nbsp; Installation</h3><div class="paragraph"><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;im.chit/hara.concurrent.procedure &quot;2.3.4&quot;&#93;
</code></pre></div><div class="paragraph"><p>All functions are in the <code>hara.concurrent.procedure</code> namespace.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(use 'hara.concurrent.procedure)</div></div></section><section class="section" id="motivation"><h3 class="section">1.2  &nbsp;&nbsp; Motivation</h3><div class="paragraph"><p>The <code>concurrent.procedure</code> construct is like a future, but contains more information and so is more <strong>self aware</strong>. This is a very useful construct for workflow modelling and concurrent applications where the library provides rich information about the execution of a particular running instance:</p><ul><li>the function that originated the process instance</li><li>the thread or future on which the instance is executing</li><li>the result (maybe cached) of the execution if returned</li><li>the time of execution</li><li>the id of the process (used for identification)</li><li>other running instances of the proces</li></ul></div></section></section><section class="chapter" id="features"><h2 class="chapter">2  &nbsp;&nbsp; Features</h2><section class="section" id="basics"><h3 class="section">2.1  &nbsp;&nbsp; Basics</h3><div class="paragraph"><p>There are many uses for a function that stores information about it's execution, as well as having it's execution properties be customised through input arguments. This will be demonstrated by creating a very simple function that waits for a second before outputting a result. As can be seen, there is an additional map before the argument vector and it's use will be shown later.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure hello {}
  []
  (Thread/sleep 1000)
  &quot;Hello&quot;)</div></div><div class="paragraph"><p>We can call hello and see that it yields a future-like reference for the execution of the function. This will be called an <code>instance</code> of execution.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hello)
;; =&gt; #proc[d858c5b0-7671-41f1-96af-fdd768c24e84]
;; {:args (), :input nil, :mode :async,
;;  :runtime {:started #inst &quot;2015-12-08T15:10:41.695-00:00&quot;},
;;  :interrupt false,
;;  :timestamp #inst &quot;2015-12-08T15:10:41.695-00:00&quot;,
;;  :result :waiting}</div></div><div class="paragraph"><p>The result of the function is shown after one second when dereferenced.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(hello)
;; =&gt; &quot;Hello&quot; &lt;after one second&gt;</div></div></section><section class="section" id="mode"><h3 class="section">2.2  &nbsp;&nbsp; Mode</h3><div class="paragraph"><p>We now change the procedure slightly by setting the mode to <code>:sync</code>, by default the mode is <code>:async</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure hello {:mode :sync}
  []
  (Thread/sleep 1000)
  &quot;Hello&quot;)</div></div><div class="paragraph"><p>Notice that the call to <code>hello</code> does not return immediately but pauses for one second before returning the execution instance. Instead of running asynchronously like before, the call is synchronous. Notice that <code>:runtime</code> has an end time and there the value for <code>:result</code> has changed from <code>:waiting</code> to a map having <code>:type</code> and <code>:data</code> keys.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hello)
;; =&gt; #proc[0deadecf-2503-4653-9380-1739c6f1b1f8]
;; {:args (), :input nil, :mode :sync,
;;  :runtime {:ended #inst &quot;2015-12-08T15:34:53.250-00:00&quot;, :started #inst &quot;2015-12-08T15:34:52.248-00:00&quot;},
;;  :interrupt false, :timestamp #inst &quot;2015-12-08T15:34:52.248-00:00&quot;,
;;  :result {:type :success, :data &quot;Hello&quot;}}</div></div><div class="paragraph"><p>When it is dereferenced, there is no difference between the dereference second and the first <code>hello</code>s</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(hello)
;; =&gt; &quot;Hello&quot; &lt;after one second&gt;</div></div></section><section class="section" id="control-of-execution"><h3 class="section">2.3  &nbsp;&nbsp; Control of Execution</h3><div class="paragraph"><p>Lets add another option to our procedure, this time <code>:arglist</code></p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure hello {:mode :sync :arglist [:mode]}
  []
  (Thread/sleep 1000)
  &quot;Hello&quot;)</div></div><div class="paragraph"><p>We should be familiar with the call to <code>hello</code> because it behaves the same to the previous definitions when called directly:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hello)
;; =&gt; #proc[7b2de1b5-267b-4d54-be66-1fd5fabd0a4c]
;; {:args (), :input nil, :mode :sync,
;;  :runtime {:ended #inst &quot;2015-12-08T15:49:35.948-00:00&quot;, :started #inst &quot;2015-12-08T15:49:34.946-00:00&quot;},
;;  :interrupt false, :timestamp #inst &quot;2015-12-08T15:49:34.946-00:00&quot;,
;;  :result {:type :success, :data &quot;Hello&quot;}}</div></div><div class="paragraph"><p>However, we can play with what mode we wish the function to run by running <code>hello</code> with an additional argument:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hello :async)
;; =&gt; #proc[50d3d2fb-faa3-4bd4-810d-936b30881b55]
;; {:args (), :input (:async), :mode :async,
;;  :runtime {:started #inst &quot;2015-12-08T15:51:08.486-00:00&quot;},
;;  :interrupt false, :timestamp #inst &quot;2015-12-08T15:51:08.486-00:00&quot;,
;;  :result :waiting}</div></div><div class="paragraph"><p>When it is dereferenced, there should be no difference of behavior to the previous definitions.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(hello :async)
;; =&gt; &quot;Hello&quot; &lt;after one second&gt;</div></div><div class="paragraph"><p>The <code>:arglist</code> can be seen as an outer wrapper on top of the original function. The arglist count should always be equal or more than the function's argument count. In this way, the execution of the function can be controlled by the caller using only data. This is extremely useful as will be seen next:</p></div></section><section class="section" id="instance"><h3 class="section">2.4  &nbsp;&nbsp; Instance</h3><div class="paragraph"><p>There are special keywords that we can put in the <code>:arglist</code> vector in order to adjust the behavior of execution. The most general is <code>:instance</code>. With <code>:instance</code>, we can overwrite any execution property. This is shown in an example below:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure hello {:mode :sync :arglist [:instance]}
  [instance]
  (Thread/sleep (:sleep instance))
  (:mode instance))</div></div><div class="paragraph"></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(hello {:sleep 2000 :mode :async})
;; =&gt; :async &lt;after two seconds&gt;</div></div><div class="paragraph"><p>We can see what the <code>instance</code> variable passed to the function actually contains:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure hello {:mode :sync :arglist [:instance]}
  [instance]
  (Thread/sleep (:sleep instance))
  (keys instance))</div></div><div class="paragraph"></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(hello {:sleep 100 :mode :async})
;; =&gt; (:args :time :arglist :registry :mode :procedure
;;     :id-fn :cache :result :id :runtime :interrupt
;;     :input :timestamp :handler :sleep) &lt;after 100ms&gt;</div></div><div class="paragraph"><p>In fact, this structure is exactly what we get when we call <code>hello</code> without dereferencing:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(keys (hello {:sleep 100 :mode :async}))
;; =&gt; (:args :time :arglist :registry :mode :procedure
;;     :id-fn :cache :result :id :runtime :interrupt
;;     :input :timestamp :handler :sleep) &lt;occurs instantly&gt;</div></div></section><section class="section" id="runtime-and-registry"><h3 class="section">2.5  &nbsp;&nbsp; Runtime and Registry</h3><div class="paragraph"><p>We can look at the function's execution through it's <code>:runtime</code> and <code>:registry</code> keys. We can reuse the previous definition of <code>hello</code> to create two long running functions:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(def a (hello {:name &quot;hello&quot; :sleep 100000 :mode :async :id &quot;instance-a&quot;}))
(def b (hello {:name &quot;hello&quot; :sleep 100000 :mode :async :id &quot;instance-b&quot;}))</div></div><div class="paragraph"><p>Now that we have the instances of execution, we can view when it has been started:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(:runtime a)
;; =&gt; #&lt;Atom@9cab002: {:started #inst &quot;2015-12-10T05:56:17.685-00:00&quot;}&gt;</div></div><div class="paragraph"><p>As well as access all running instances through a global registry:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(:registry a)
;; =&gt; #reg {&quot;hello&quot; (&quot;instance-b&quot; &quot;instance-a&quot;)}</div></div><div class="paragraph"><p>We can stop the execution of <code>instance a</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(require '[hara.concurrent.procedure.registry :as registry])</div></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(registry/kill (:registry a) &quot;hello&quot; &quot;instance-a&quot;)
;; =&gt; true</div></div><div class="paragraph"><p>A check will reveal that <code>instance b</code> is still running</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(:registry a)
;; =&gt; #reg {&quot;hello&quot; (&quot;instance-b&quot;)}</div></div><div class="paragraph"><p><code>instance-b</code> is accessible from <code>instance-a</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(-&gt; a :registry deref (get &quot;hello&quot;) (get &quot;instance-b&quot;))
;; =&gt; #proc[instance-b]{:args (nil),
;; :input ({:name &quot;hello&quot;, :mode :async, :id &quot;instance-b&quot;, :sleep 100000}), :mode :async,
;; :runtime {:started #inst &quot;2015-12-10T06:02:21.752-00:00&quot;},
;; :interrupt false, :timestamp #inst &quot;2015-12-10T06:02:21.752-00:00&quot;,
;; :result :waiting, :name &quot;hello&quot;}</div></div><div class="paragraph"><p>As well as to be killed from from <code>instance-a</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(registry/kill (:registry a) &quot;hello&quot; &quot;instance-b&quot;)
;; =&gt; true</div></div><div class="paragraph"></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(:registry a)
;; =&gt; #reg {}</div></div><div class="paragraph"><p>This is very useful for coordinating strategies between execution instances.</p></div></section><section class="section" id="identity-and-caching"><h3 class="section">2.6  &nbsp;&nbsp; Identity and Caching</h3><div class="paragraph"><p>In the previous section, there were concepts like <code>:id</code> and <code>:name</code> being introduced. These properties give context to the type of function being executed as well as to identify duplicates and wasted execution. To be able to uniquely identify an instance of execution as being the same as another means that additional operations such as caching, timeouts and interrupts can be used for control of execution.</p></div><div class="paragraph"><p>Let's look at a particular use case where results can be cached. The <code>power</code> function has been written using <code>defprocedure</code> to include caching. </p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure power {:arglist [:x :instance] :id-fn :x :cached true :name &quot;power&quot; :interrupt true}
  ([x] @(power x {}))
  ([x instance]
   (Thread/sleep 100)
   (if (zero? x)
     1
     (* x @(power (dec x) (select-keys instance [:cached]))))))</div></div><div class="paragraph"><p>More about the parameters will be explained later but first, let's try this out. We will calculate 20! and see the caching kick in after the second try:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(power 20)
;; =&gt; 2432902008176640000 &lt;after some time&gt;

@(power 20)
;; =&gt; 2432902008176640000 &lt;instantaneously&gt;</div></div><div class="paragraph"><p>Sometimes, we actually wish to ignore the cache and have it recalculate. This can be done through arguments instead of any special forms</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(power 20 {:cached false})
;; =&gt; 2432902008176640000 &lt;after some time&gt;

@(power 20)
;; =&gt; 2432902008176640000 &lt;instantaneously&gt;</div></div><div class="paragraph"><p>We can look at the cached values directly from the instance:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(:cache (power 20))
;; =&gt; #cache {&quot;power&quot; {0 ((0 nil)), 7 ((7 nil)), 20 ((20) (20 nil)),
;;                     1 ((1 nil)), 4 ((4 nil)), 15 ((15 nil)), 13 ((13 nil)),
;;                     6 ((6 nil)), 17 ((17 nil)), 3 ((3 nil)), 12 ((12 nil)),
;;                     2 ((2 nil)), 19 ((19 nil)), 11 ((11 nil)), 9 ((9 nil)),
;;                     5 ((5 nil)), 14 ((14 nil)), 16 ((16 nil)), 10 ((10 nil)),
;;                     18 ((18 nil)), 8 ((8 nil))}}</div></div><div class="paragraph"><p>In concurrent applications, where multiple processes may be doing the same calculation, this type of mechanism will be able to save quite a few clock cycles when used in the right way.</p></div></section><section class="section" id="intermission"><h3 class="section">2.7  &nbsp;&nbsp; Intermission</h3><div class="paragraph"><p>Let's switch gears a little bit and talk philosophy. In working with the standard concurrent execution contructs like futures and promises, it was found that they lacked the self-awareness to coordinate with each other. The reason behind this is very simple: there is dissociation between what should be three concepts critical to concurrent execution: the function (governed by its definition), the execution (governed by time) and the result (governed by input).</p></div><section class="subsection" id="synchronous-execution"><h4 class="subsection">2.7.1  &nbsp;&nbsp; Synchronous Execution</h4><div class="paragraph"><p>Execution is not an issue in a synchronous world; it occurs with the ticking of the system clock and there are no other processes that are able to affect the world, we can establish a link between the <strong>past</strong> and the <strong>future</strong> because there is no <strong>present</strong> as such in terms of what is happening right now. It just doesn't exist, or rather we don't need to account for it in order to build our programs. In the synchronous world, there is no difference between a function and a lookup table of inputs and outputs</p></div><div class="figure"><a name="the-synchronous-world"></a><div class="img"><img height="500px" src="img/hara_concurrent_procedure/synchronous.png" /></div><h4><i>fig.1  &nbsp;-&nbsp; The Synchronous World</i></h4></div></section><section class="subsection" id="concurrent-execution"><h4 class="subsection">2.7.2  &nbsp;&nbsp; Concurrent Execution</h4><div class="paragraph"><p>In the concurrent world things happen very differently; or rather, things are required to be accounted very differently in order for a program to succeed. Time the conquerer is the master behind all calculation. To neglect time is a idealistic and will ultimately result in failure.</p></div><div class="figure"><a name="the-concurrent-world"></a><div class="img"><img height="500px" src="img/hara_concurrent_procedure/concurrent.png" /></div><h4><i>fig.2  &nbsp;-&nbsp; The Concurrent World</i></h4></div></section><section class="subsection" id="coordination-of-concurrent-execution"><h4 class="subsection">2.7.3  &nbsp;&nbsp; Coordination of Concurrent Execution</h4><div class="paragraph"><p>An example of how this could be useful can be shown below.</p></div><div class="figure"><a name="execution-coordination"></a><div class="img"><img src="img/hara_concurrent_procedure/example.png" width="100%" /></div><h4><i>fig.3  &nbsp;-&nbsp; Execution Coordination</i></h4></div><div class="paragraph"><p>Computation <strong>C</strong> is estimated to take 10 hours to complete and both process A and process B both require the same result. Now, process A has started computation for 9 and a half hours but has not finished and process B is starting. In this case, instead of waiting another 10 hours for computation, if process B is aware that process A is already doing the computation, all it needs to do is to wait on the result of A instead of starting from scratch.</p><p>Instead of taking 10 hours, process B will just take 0.5 hours.</p></div></section></section><section class="section" id="overwrite"><h3 class="section">2.8  &nbsp;&nbsp; Overwrite</h3><div class="paragraph"><p>Caching is a part of the bigger problem of how calculation can be shared between one or more concurrent processes. So when working with caching, we have to think about coordination and how processes should be able to work together. Lets try this out with a function that returns a random integer between 0 and 1000.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure random-int {:arglist [:instance]
                          :id-fn (constantly &quot;current&quot;)
                          :cached true
                          :name &quot;random&quot;
                          :interrupt true}
  ([instance] (rand-int 1000)))</div></div><div class="paragraph"><p>Lets give this a go by making two calls and watching the cache kick in:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(random-int {})
;; =&gt; 675

@(random-int {})
;; =&gt; 675</div></div><div class="paragraph"><p>This is may or may not be good depending on the problem. Imagine something like multiple concurrent processes hitting a database to retrieve the same value. Sometimes, we want to make a call without affecting everyone else; other times, we would wish to make a call and then update it globally for all processes. A combination of <code>:cached</code> and <code>:overwrite</code> allows this to happen.</p></div><div class="paragraph"><p>In the first case, we see that <code>:overwrite true</code> will update the cache with a new value:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(random-int {:overwrite true})
;; =&gt; 132
@(random-int {})
;; =&gt; 132</div></div><div class="paragraph"><p>In the second case, we see that <code>:cached false</code> will return the value whilst skipping the cache altogether</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(random-int {:cached false})
;; =&gt; 276
@(random-int {})
;; =&gt; 132</div></div></section><section class="section" id="interrupt"><h3 class="section">2.9  &nbsp;&nbsp; Interrupt</h3><div class="paragraph"><p>Another important characteristic is that sometimes, a process is taking too long and we need to restart it. We construct a function showing 50% chance of failure.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure random-failure {:arglist [:instance]
                              :id-fn (constantly &quot;current&quot;)
                              :name &quot;random&quot;}
  ([instance]
   (println &quot;Function Started:&quot; (:timestamp instance) )
   (if (&gt; 0.5 (rand))
     (Thread/sleep 1000000))
   (println &quot;Function Finished: &quot; (:timestamp instance))))</div></div><div class="paragraph"><p>The function behavior can be activated by calling it a few times. As the probabily of failure is quite high, We find that there is no output for <code>Function Finished</code>.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(random-failure {})
;; Function Started: #inst &quot;2015-12-13T10:21:28.382-00:00&quot;
;; Function Finished:  #inst &quot;2015-12-13T10:21:28.382-00:00&quot;

(random-failure {})
;; Function Started: #inst &quot;2015-12-13T10:21:29.757-00:00&quot;</div></div><div class="paragraph"><p>Our function is set so that another call of the same type will just wait, subsequent calls will block for the calculation:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(random-failure {})
;; =&gt; &lt;No output&gt;</div></div><div class="paragraph"><p>By default, a called procedure will block and wait on another of the same type to finish before returning the result. However, if it is required to kill a procedure that is taking too long to finish, setting <code>:interrupt true</code> will interrupt the current execution and proceed again from the beginning:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(random-failure {:interrupt true})
;; Function Started: #inst &quot;2015-12-13T11:35:28.751-00:00&quot;
;; Function Finished:  #inst &quot;2015-12-13T11:35:28.751-00:00&quot;</div></div><div class="paragraph"><p>This is used for mitigating coordination problems when one process is waiting on the other without reason.</p></div></section><section class="section" id="time"><h3 class="section">2.10  &nbsp;&nbsp; Time</h3><div class="paragraph"><p>We can access information about the instant's start and end time through the <code>:runtime</code> key. The <code>:timestamp</code> key is used for coordination between processes that may have started at slightly different times due to the randomness of the thread pool. We see an example below:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure current [:instance]
  [instance]
  (Thread/sleep 100)
  (-&gt; instance
      (select-keys [:timestamp :runtime])))</div></div><div class="paragraph"><p>A call to <code>current</code> returns information about the operation:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(-&gt; @(current {})
    (update-in [:runtime] deref))
;; =&gt; {:runtime {:ended #inst &quot;2015-12-13T13:54:24.475-00:00&quot;,
;;               :started #inst &quot;2015-12-13T13:54:24.371-00:00&quot;},
;;     :timestamp #inst &quot;2015-12-13T13:54:24.371-00:00&quot;}</div></div><div class="paragraph"><p>By default, the value of <code>:timestamp</code> is same as <code>:started</code>. However, we can also pass in the exact <code>:timestamp</code> we want the function to have as it's argument.</p></div></section></section><section class="chapter" id="retries"><h2 class="chapter">3  &nbsp;&nbsp; Retries</h2><div class="group"><div class="paragraph"><p>In the real world, there is always going to be failure and having the ability to deal with failure is key to system robustness. Retries are a very important feature for any concurrent process as it allows for strategies to be implemented on failure.</p><p>When a function throws an exception, we wish to then be able to adjust and calmly start again with either the same call or another strategy for mitigation. Although this can be done using <code>try</code>/<code>catch</code> blocks, <code>hara.concurrent.procedure</code> offers an elegant alternative.</p></div></div><section class="section" id="simple"><h3 class="section">3.1  &nbsp;&nbsp; Simple</h3><div class="paragraph"><p>We can construct the most basic retry</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure retry-println
  {:retry {:on Throwable
           :limit  3
           :wait   1000}}
  []
  (println &quot;Started Function&quot;)
  (throw (Exception. &quot;Hello&quot;)))</div></div><div class="paragraph"><p>Lets run the function and see what happens:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(retry-println)
;; Started Function
;; &lt;1000 ms pause&gt;
;; Started Function
;; &lt;1000 ms pause&gt;
;; Started Function
;; &lt;1000 ms pause&gt;
;; Started Function
;; Exception Hello</div></div><div class="paragraph"><p>Notice that the function starts, errors and then retries 3 times, pausing 1000ms before each retry. Once it reaches the limit of 3, the function gives up and throws the error.</p></div></section><section class="section" id="wait"><h3 class="section">3.2  &nbsp;&nbsp; Wait</h3><div class="paragraph"><p>An important variable to control is the wait time. We construct the next example to explain this feature:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure restart-wait
  {:retry {:on Throwable
           :limit  3
           :wait   (fn [state count]
                     (let [t (* count 1000)]
                       (println &quot;STATE:&quot; state &quot;WAITING&quot; t &quot;ms&quot;  )
                       t))}}
  []
  (println &quot;Started Function&quot;)
  (throw (Exception. &quot;Hello&quot;)))</div></div><div class="paragraph"><p>Instead of using a fixed value for the wait time, it is controllable by passing a function taking two parameters: <code>state</code> (which is used to hold data about the current status of the retries) and <code>count</code> (the number of retries attempted). The output of this function is shown below:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(restart-wait)
;; Started Function
;; STATE: nil WAITING 0 ms
;; Started Function
;; STATE: nil WAITING 1000 ms
;; Started Function
;; STATE: nil WAITING 2000 ms
;; Started Function
;; Exception Hello</div></div></section><section class="section" id="arguments"><h3 class="section">3.3  &nbsp;&nbsp; Arguments</h3><div class="paragraph"><p>The difference between <code>hara.concurrent.procedure</code> and other libraries for concurrent constructs lie in the fact that the modes of operation such as caching, timing, threads and other runtime decisions can be passed to the function itself. This also applies to retry strategies as well.  can be passed in as arguments to affect how a function is evaluated. We see an example of a procedure:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure restart-args [:instance]
  []
  (println &quot;Started Function&quot;)
  (throw (Exception. &quot;Hello&quot;)))</div></div><div class="paragraph"><p>When it is called directly, the output is predictable:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(restart-args)
;; Started Function
;; Exception Hello</div></div><div class="paragraph"><p>When it is called with retry options, there is a very different output:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(restart-args {:retry {:on Throwable
                        :limit  3
                        :wait   (fn [state count]
                                  (let [t (* count 1000)]
                                    (println &quot;WAITING&quot; t &quot;ms&quot;)
                                    t))}})
;; Started Function
;; WAITING 0 ms
;; Started Function
;; WAITING 1000 ms
;; Started Function
;; WAITING 2000 ms
;; Started Function
;; Exception Hello</div></div><div class="paragraph"><p>The advantage of this approach is significant. Most of the time, the modes of execution are hard-coded and so cannot be changed. With parameterised control of execution, how a function is run is now totally in the hands of the caller and so allows much more freedom and flexible for how systems can be defined.</p></div></section><section class="section" id="handlers"><h3 class="section">3.4  &nbsp;&nbsp; Handlers</h3><div class="paragraph"><p>The retry handler mechanism is compatible with <code>hara.event</code> and offers the same semanitics for querying on exception data. Notice that multiple handlers can be set up for the procedure.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defprocedure restart-cats
  {:arglist [:instance]
   :retry {:handlers [{:on    {:cats odd?}
                       :apply (fn [state e]
                                (-&gt; state
                                    (update-in [:types (type e)] (fnil inc 0))
                                    (update-in [:total]
                                               (fnil (fn [out]
                                                       (if (&gt; 0.3 (rand))
                                                         (inc out)
                                                         out))
                                                     0))))
                       :wait  100
                       :limit 100}]}}
  [instance]
  (println (-&gt; instance :retry :count)
           (-&gt; instance :retry :state))
  (if-let [res (-&gt; instance :retry :state :total)]
    (if (&lt; res 5)
      (throw (ex-info &quot;Cats&quot; {:cats 3})))
    (throw (ex-info &quot;Cats&quot; {:cats 3}))))</div></div><div class="paragraph"><p>We can see the results of the output:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">@(restart-cats {})
;; nil nil
;; 1 {:total 1, :types {clojure.lang.ExceptionInfo 1}}
;; 2 {:total 2, :types {clojure.lang.ExceptionInfo 2}}
;; 3 {:total 3, :types {clojure.lang.ExceptionInfo 3}}
;; 4 {:total 3, :types {clojure.lang.ExceptionInfo 4}}
;; 5 {:total 3, :types {clojure.lang.ExceptionInfo 5}}
;; 6 {:total 3, :types {clojure.lang.ExceptionInfo 6}}
;; 7 {:total 4, :types {clojure.lang.ExceptionInfo 7}}
;; 8 {:total 4, :types {clojure.lang.ExceptionInfo 8}}
;; 9 {:total 4, :types {clojure.lang.ExceptionInfo 9}}
;; 10 {:total 4, :types {clojure.lang.ExceptionInfo 10}}
;; 11 {:total 5, :types {clojure.lang.ExceptionInfo 11}}</div></div><div class="paragraph"><p>Lets talk a little about <code>state</code>. In many failure scenarios, there are particular strategies that one needs to apply in order to mitigate a particular situation. <code>:apply</code> is a way to manipulate the state based upon the previous state and the exception that occurred. Using a combination of <code>:apply</code> and <code>:wait</code> will allow most retry strategies to be expressed.</p></div><div class="paragraph"><p>Some more sample <code>:handlers</code> can be seen below. The parameters outside of the <code>:handlers</code> vector are default values.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">{:retry {:handlers [{:on #{Exception}
                     :apply   (fn [state e])
                     :limit   (fn [state count])
                     :wait    (fn [state count])}
                    {:on Error
                     :apply   (fn [state e])
                     :limit   :no}
                    {:on     (fn [e] (instance? Throwable e))
                     :apply  (fn [state e])
                     :limit  :no}]
         :on Throwable
         :count 0
         :state  {:a 1 :b 2}
         :limit 10
         :wait  100}}</div></div></section></section>
    </div>
</div><!--end of .container-->

  <section class="application">
    
  </section>
</body>

<script>
  $('#nav').affix({
    offset: {
        top: $('#nav').offset().top,
        bottom: $('footer').outerHeight(true) + $('.application').outerHeight(true) + 40
    }});
</script>


<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</body>
</html>
